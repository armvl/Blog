--
-- PostgreSQL database dump
--

-- Dumped from database version 16.0 (Debian 16.0-1.pgdg120+1)
-- Dumped by pg_dump version 16.0 (Debian 16.0-1.pgdg120+1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Data for Name: account; Type: TABLE DATA; Schema: public; Owner: blog
--

COPY public.account (id, uid, name, "create", update) FROM stdin;
1	0aecb25f-f8d6-4e6f-abf7-47cca8594a06	test account	2023-10-30 12:40:28.352494+00	2023-10-30 12:40:28.352494+00
2	d2e17339-8d22-4948-9d76-10df95e42b84	Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36	2023-10-30 12:40:28.352494+00	2023-10-30 12:40:28.352494+00
\.


--
-- Data for Name: post; Type: TABLE DATA; Schema: public; Owner: blog
--

COPY public.post (id, uid, account_id, title, entry, content, "create", update) FROM stdin;
78	acde9568-fc82-41e6-a7d1-cd4d98166f3f	2	Мнение три года спустя: стоил ли того переход с JavaScript на Rust?	<figure class="full-width "><img style="display: block; margin-left: auto; margin-right: auto;" title="Озадаченный краб" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/306/859/f9a/306859f9aaace336f37254c765389f36.png" alt="Озадаченный краб" width="430" height="455" data-src="https://habrastorage.org/getpro/habr/upload_files/306/859/f9a/306859f9aaace336f37254c765389f36.png"><figcaption>Озадаченный краб</figcaption></figure><p>Несколько лет назад я отказался от всего и полностью сосредоточился на WebAssembly. В то время Rust имел наилучшую поддержку компиляции в WebAssembly, а самые полнофункциональные среды исполнения WebAssembly были основаны на Rust. Rust был лучшим из вариантов. С места в карьер я нетерпеливо начал разбираться, чем же вызван такой ажиотаж.</p>	<p>С тех пор мы с ещё несколькими потрясающими разработчиками создали <a href="https://github.com/candlecorp/wick" rel="noopener noreferrer nofollow"><u>Wick</u></a>, — фреймворк приложений и среду исполнения, использующие в качестве системы основного модуля WebAssembly.</p><figure class="full-width "><img title="Wick был главной целью наших экспериментов с Rust" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/5a0/a72/888/5a0a72888cf398b713f91c5b2133a2fa.png" alt="Wick был главной целью наших экспериментов с Rust" width="645" height="205" data-src="https://habrastorage.org/getpro/habr/upload_files/5a0/a72/888/5a0a72888cf398b713f91c5b2133a2fa.png"><figcaption>Wick был главной целью наших экспериментов с Rust</figcaption></figure><p>Спустя три года, выполнив несколько развёртываний в продакшен, написав <a href="https://github.com/jsoverson/node-to-rust" rel="noopener noreferrer nofollow"><u>электронную книгу</u></a> и выпустив примерно сто пакетов на <a href="https://crates.io/me/crates" rel="noopener noreferrer nofollow"><u>crates.io</u></a>, я решил, что настало время поделиться своими мыслями о Rust.</p><h2>Хорошее</h2><h3>Можно поддерживать больше меньшими усилиями</h3><p>Я сильный сторонник разработки через тестирование (test-driven development). Я привык к тестированию в языках наподобие Java и JavaScript. Я начал писать тесты на Rust, как на любом другом языке, но обнаружил, что пишу тесты, которые <em>не могут завершиться ошибкой</em>. Достигнув момента, когда ваши тесты могут выполняться, то есть когда код на Rust компилируется, Rust уже учёл столько ошибок, что стандартные тестовые случаи становятся нерелевантными. Если вы избегаете блоков <code>unsafe {}</code> и подверженных панике методов наподобие <code>.unwrap()</code>, то начинаете с фундамента, который изначально обходит стороной множество проблем.</p><p>Агрессивность borrow checker, богатство системы типов, функциональные шаблоны и библиотеки, отсутствие «пустых» значений позволяет поддерживать больше, тратя меньше усилий на вещи наподобие тестирования. В проекте Wick я поддерживал более семидесяти тысяч строк кода с гораздо меньшим количеством тестов, чем мне бы потребовалось в других языках.</p><p>Когда необходимо писать тесты, можно легко добавлять их на лету, не задумываясь об этом. Интегрированные средства тестирования Rust позволяют практически без заминок добавлять тесты прямо рядом с кодом.</p><h3>Теперь я пишу более качественный код на других языках</h3><p>Программирование на Rust похоже на отношения с эмоциональным абьюзом. Rust кричит на тебя каждый день, часто ругаясь на то, что в другой жизни ты счёл бы абсолютно нормальным. Со временем ты привыкаешь к истерикам. Они становятся рутиной. Ты приучаешься ходить по струнке, чтобы избежать вспышек гнева компилятора. Как и в реальной жизни, эти изменения в поведении остаются с тобой навсегда.</p><p>Эмоциональный абьюз обычно не считается <em>здоровым</em> способом стимулировать к изменениям, но он всё равно меняет тебя.</p><p>Теперь я не могу писать код на других языках без ощущения дискомфорта, если строки находятся в беспорядке или когда возвращаемые значения не проверяются. Кроме того, я испытываю иррациональное раздражение, когда сталкиваюсь с ошибками при исполнении.</p><figure class="full-width "><img title='Что значит “done" не функция? Почему ты мне не сказал, что "done” может не быть функцией??' src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/b34/335/8e0/b343358e0bc5895144bdabec1c273fe2.png" alt='Что значит “done" не функция? Почему ты мне не сказал, что "done” может не быть функцией??' width="680" height="237" data-src="https://habrastorage.org/getpro/habr/upload_files/b34/335/8e0/b343358e0bc5895144bdabec1c273fe2.png"><figcaption><em>Что значит “</em><code>done"</code><em> не функция? Почему ты мне не сказал, что "</em><code>done”</code><em> может не быть функцией??</em></figcaption></figure><h3>Clippy великолепен!</h3><p><a href="https://github.com/rust-lang/rust-clippy" rel="noopener noreferrer nofollow"><u>Clippy</u></a> — это линтер Rust, но называть его линтером было бы медвежьей услугой. В языке, компилятор которого может довести до слёз, Clippy больше похож на вежливого друга, чем на линтер.</p><p>Стандартная библиотека Rust <em>огромна.</em> В ней сложно находить функции, о существовании которых вы догадываетесь, ведь так много функциональности распределено по множеству несвязанных типов, типажей, макросов и функций. Многие правила Clippy (например, <code>manual_is_ascii_check</code>) ищут распространённые шаблоны, которые лучше заменить методами или типами stdlib.</p><p>У Clippy есть <a href="https://rust-lang.github.io/rust-clippy/master/index.html" rel="noopener noreferrer nofollow"><u>сотни правил</u></a>, касающихся производительности, читаемости и излишних косвенных действий. По возможности он часто подсказывает код на замену.</p><p>Кроме того, похоже, что скоро мы <a href="https://github.com/rust-lang/cargo/issues/12115" rel="noopener noreferrer nofollow"><u>наконец</u></a> сможем конфигурировать для проекта глобальные линты. А пока нам приходится создавать хаки с решениями, чтобы поддерживать целостность линтов в проектах. В Wick мы используем скрипт для автоматического обновления <a href="https://github.com/candlecorp/wick/blob/main/src/main.rs#L8-L84" rel="noopener noreferrer nofollow"><u>встроенных конфигураций линтов</u></a> для нескольких десятков крейтов. Для реализации решения этого сообществу Rust потребовались <a href="https://github.com/rust-lang/cargo/issues/5034" rel="noopener noreferrer nofollow"><em><u>годы</u></em></a>, что плавно подводит нас к разделу...</p><h2>Плохое</h2><h3>Есть пробелы, с которыми придётся жить</h3><p>Я сомневался в своём здравом уме каждый раз, когда возвращался к описанной выше проблеме с Clippy. Я ведь точно ошибаюсь. Наверно, есть конфигурация, которую я упустил. Я не мог в это поверить, и по-прежнему не могу. Наверняка есть способ глобального конфигурирования линтов. Я <a href="https://github.com/rust-lang/cargo/issues/5034" rel="noopener noreferrer nofollow"><u>четырежды</u></a> <a href="https://github.com/rust-lang/rust/issues/45832" rel="noopener noreferrer nofollow"><u>проверил</u></a> <a href="https://github.com/rust-lang/rust-clippy/issues/1313" rel="noopener noreferrer nofollow"><u>это</u></a> перед <a href="https://github.com/rust-lang/rust-clippy/issues/6625" rel="noopener noreferrer nofollow"><u>написанием</u></a> <a href="https://www.appsloveworld.com/rust/4/how-can-i-have-a-shared-clippy-configuration-for-all-the-crates-in-a-workspace" rel="noopener noreferrer nofollow"><u>своей</u></a> <a href="https://github.com/EmbarkStudios/rust-ecosystem/issues/22" rel="noopener noreferrer nofollow"><u>статьи</u></a>, чтобы убедиться, что не брежу. Эти issue теперь закрыты, но они были открыты в течение нескольких лет.</p><p>Clippy прекрасен, но этот случай — лишь один из множества в мире Rust. Я часто натыкался на библиотеки или инструменты, не соответствующие моим сценариям использования. Это довольно часто бывает с новыми языками и проектами. Чтобы повзрослеть, программному обеспечению нужно время. Но Rust не <em>настолько</em> новый. Чем-то он отличается от всего остального.</p><p>В опенсорсе проблемы пограничных случаев решают или рано влившиеся в проект, или новички. Именно у них возникают пограничные случаи. Их PR совершенствуют проекты, чтобы они были лучше для следующих пользователей. <a href="https://github.blog/2023-08-30-why-rust-is-the-most-admired-language-among-developers/" rel="noopener noreferrer nofollow"><u>Большую часть десятилетия Rust награждали титулом «самого любимого языка»</u></a>. У него нет проблем с привлечением новых пользователей, но это не приводит к существенному совершенствованию библиотек или инструментов. Это приводит к единичным случаям форков, обрабатывающих конкретные сценарии применения. Я тоже виновен в этом, но не из-за нехватки желания отправлять PR.</p><p>Не знаю, в чём причина. Возможно, требование поддержания стабильных API, наряду с гранулярной системой типов Rust, усложняет владельцам библиотек их итеративное развитие. Сложно принять мелкое изменение, если это приведёт к смене основной версии.</p><p>А может быть, это вызвано тем, что написание кода на Rust, который делает всё для всех, чрезвычайно сложно, и разработчики просто не хотят с этим связываться.</p><h3>Cargo, crates.io и структурирование проектов</h3><p>Я моделировал структуру репозитория Wick на основании других найденных мной популярных проектов. Она выглядела разумно и хорошо работала, пока всё не поменялось.</p><p>При помощи Cargo можно собирать, тестировать и использовать то, что похоже на крейт размером с модуль. Но развёртывание на crates.io — это совсем другое дело.</p><p>На crates.io нельзя публиковать пакеты, если только <strong>каждый</strong> крейт, на который есть ссылка, тоже не опубликован отдельно. Это имеет некий смысл. Не хочется зависеть от крейта, зависящего от пакетов, существующих только в локальной файловой системе автора.</p><p>Однако многие разработчики естественным образом разбивают крупные проекты на более мелкие модули, но нельзя опубликовать родительский крейт, имеющий подкрейты, которые <em>существуют только внутри себя. </em>Нельзя даже опубликовать крейт, имеющий локальные зависимости этапа разработки. Нужно выбрать: или публиковать произвольные вспомогательные крейты, или реструктурировать проект, чтобы избежать этой проблемы. Такое ограничение кажется надуманным и необязательным. Структурированные таким образом проекты можно собирать, их нельзя только публиковать.</p><blockquote><p><em>Дополнение: </em><a href="https://www.reddit.com/r/rust/comments/17gnkh2/was_rust_worth_it/k6jf2c0/" rel="noopener noreferrer nofollow"><em><u>Эд Пейдж написал мне</u></em></a><em>, что можно публиковаться с локальными зависимостями этапа разработки, если не включать </em><code>version</code> в <code>Cargo.toml</code></p></blockquote><p>Однако Cargo имеет превосходную поддержку рабочих пространств! Рабочие пространства Cargo позволяют удобнее управлять крупными проектами, чем большинство языков. Но они не решают проблему с развёртыванием. Оказалось, что можно настроить рабочие пространства десятком разных способов, но <em>ни один</em> из них не упрощает развёртывание.</p><p>Эта проблема проявляет себя самим количеством <a href="https://crates.io/search?q=cargo+workspace+publish" rel="noopener noreferrer nofollow"><u>вспомогательных крейтов</u></a>, разработанных для упрощения публикации рабочих пространств. Каждый из них работает с подмножеством конфигураций, и «единственно верный способ» настройки рабочих пространств по-прежнему ускользает от меня. При публикации Wick часто требуется больше часа сочетания ручных повторяющихся задач с инструментами, работающими лишь частично.</p><h3>Async</h3><p>Асинхронность введена в Rust после его появления. Она ощущается как запоздалое решение и часто становится помехой из-за ошибок, которые трудно понять и устранить. При поиске решений нужно фильтровать информацию в зависимости от сред исполнения и стилей их async. Хотите использовать async-библиотеку? Есть вероятность, что её нельзя использовать за пределами конкретной среды исполнения async.</p><p>После двух десятков лет работы с JavaScript и приличного опыта взаимодействия с Go это <em>наиболее существенный</em> источник головной боли в Rust. Это преодолимая проблема, но всегда следует готовиться бороться с чудовищем async, когда оно поднимает свою голову. В других языках async практически невидим.</p><h2>Ужасное</h2><h3>Рефакторинг может быть сложным</h3><p>Богатая система типов Rust — это и благословление, и проклятие. Думать типами Rust прекрасно. Управлять типами Rust ужасно. Данные и сигнатуры функций могут иметь обобщённые типы, обобщённое время жизни и ограничения типажей. Эти ограничения могут иметь собственные обобщённые типы и время жизни. <a href="https://github.com/rxRust/rxRust/blob/master/src/observable.rs#L1134-L1142" rel="noopener noreferrer nofollow"><u>Иногда ограничений типов больше, чем самого кода</u></a>.</p><figure class="full-width "><img title="Ограничений больше, чем логики" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/6d4/c23/169/6d4c231694dcf971f2a3ee895fb5a3fa.png" alt="Ограничений больше, чем логики" width="700" height="332" data-src="https://habrastorage.org/getpro/habr/upload_files/6d4/c23/169/6d4c231694dcf971f2a3ee895fb5a3fa.png"><figcaption>Ограничений больше, чем логики</figcaption></figure><p>Кроме того, дженерики нужно определять в <a href="https://github.com/bytecodealliance/wasmtime/blob/038ddfeb6699591b5d82546c9b2d5076097bc9ce/cranelift/entity/src/iter.rs#L29-L58" rel="noopener noreferrer nofollow"><u>каждом </u></a><code>impl</code>. Когда пишешь код впервые, это может быть монотонным. При рефакторинге это может превратить небольшое изменение в каскадно распространяющийся хаос.</p><figure class="full-width "><img title="Многократное дублирование простых обобщённых ID." src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/ebf/b7b/1f0/ebfb7b1f04001453b1dc9a4ebb1523a8.png" alt="Многократное дублирование простых обобщённых ID." width="652" height="655" data-src="https://habrastorage.org/getpro/habr/upload_files/ebf/b7b/1f0/ebfb7b1f04001453b1dc9a4ebb1523a8.png"><figcaption>Многократное дублирование простых обобщённых ID.</figcaption></figure><p>Сложно быстро двигаться вперёд, когда для одного шага необходимо изменить 14 разных определений.</p><p><em>Дополнение в ответ на комментарии: проблема не в выразительности, а в том, что в языке и инструментарии нет решения для снижения дублирования. Часто, бывает, нужно иметь одинаковые ограничения или ссылаться на одинаковые обобщённые списки, но нет никакого способа создания псевдонимов или как-то иначе ссылаться на центральное определение. Не уверен, должно ли оно быть, но это никак не облегчает бремя дублирования.</em></p><h2>Вердикт</h2><p>Я люблю Rust. Мне нравится то, что он может делать, и его гибкость. Я могу писать код системного уровня на том же языке, что и приложения CLI, веб-серверы и веб-клиенты. Благодаря WebAssembly я могу использовать один и тот же двоичный файл для запуска LLM <a href="https://wasm.candle.dev/llama2" rel="noopener noreferrer nofollow"><u>в браузере</u></a>, что и в командной строке. Это по-прежнему кажется мне невероятным.</p><p>Мне нравится, насколько надёжными могут быть программы на Rust. Сложно возвращаться к другим языкам, когда поймёшь, от чего тебя оберегает Rust. Я ненадолго возвращался к Go. Меня снова быстро опьянила скорость разработки. Но потом я столкнулся с паниками среды исполнения, и иллюзии разбились в прах.</p><p>Однако у Rust есть свои изъяны. Сложно искать разработчиков на нём, он медленно изучается и слишком строг для быстрых итераций. На нём сложно устранять проблемы с памятью и производительностью, особенно в асинхронном коде. Не все библиотеки хорошо справляются с безопасным кодом, а инструментарий разработки оставляет желать лучшего. Ты начинаешь с запозданием, и тебе приходится преодолевать множество препятствий. Но если ты с ними справишься, то обгонишь всех. И это «если» здесь очень важно.</p><p>Оправдал ли себя переход на Rust в нашем случае? Об этом слишком рано говорить. Мы создавали потрясающие вещи небольшой командой, но и сталкивались с серьёзными проблемами. Кроме того, у нас были технические причины для выбора Rust.</p><p>Стоит ли выбирать его вам? Если вам нужны быстрые итерации, то, вероятно, нет. Если масштаб проекта известен или вы можете пойти на первоначальные большие затраты, то определённо стоит над этим подумать. В конечном итоге вы получите практически идеальное ПО. Учитывая ежемесячно растущую популярность WebAssembly, перспектива <em>единовременного</em> написания идеального ПО и его <em>повсеместного </em>использования, скорее всего, оправдает себя.</p>	2023-11-13 14:15:15.664966+00	2023-11-14 09:42:49.868536+00
23	791fe4ba-87a9-4c71-a967-e27b990e4cfd	2	MCS и Postgres Professional запускают облачный сервис управляемой базы данных Postgres Pro	<p><img src="https://habrastorage.org/r/w1560/webt/f0/hg/sk/f0hgsk7eytn00vlftn20azs2dwi.jpeg" data-src="https://habrastorage.org/webt/f0/hg/sk/f0hgsk7eytn00vlftn20azs2dwi.jpeg">Облачная платформа Mail.ru Cloud Solutions совместно с Postgres Professional разработали облачный сервис управляемой базы данных, предоставляемый по модели Database-as-a-Service — <a href="https://mcs.mail.ru/databases/postgres-pro/">Postgres Pro Cloud</a>. Решение обеспечивает надежное и безопасное хранение информации, быстродействие систем и легкость масштабирования.</p>	<p>Новое решение позволяет повысить эксплуатационные характеристики системы управления реляционными базами данных, а также избавляет заказчиков от необходимости приобретать аппаратные и программные ресурсы. Кроме того, новое решение упрощает масштабирование БД: в облаке можно оперативно нарастить объем и мощности.<br><br>Postgres Pro Cloud доступен пользователям в формате «база данных как услуга» (Database-as-a-Service). Благодаря этому можно в несколько кликов получить готовую к работе БД в нужной конфигурации. Установка, настройка и поддержка СУБД выполняется на стороне провайдера. Размещение БД в облаке позволяет организовать безопасное хранение данных: высокая доступность и надежная защита информации в совокупности с резервным копированием и отказоустойчивым хранением нивелируют риски потерь и утечек. Для работы с данными пользователи облачной платформы могут подключить сервисы обработки и аналитики и построить на этой основе Data Lake.<br><br>Компании, заинтересованные в использовании масштабируемой и безопасной БД с посекундной оплатой за расходуемые ресурсы, могут перенести данные в Postgres Pro Cloud из любого источника: частного или публичного облака или физической инфраструктуры. Эксперты Mail.ru Cloud Solutions и Postgres Pro помогают с миграцией и консультируют по созданию масштабируемой и отказоустойчивой структуры хранения данных, а также по настройке взаимодействия с On Premises-системами, процессам ETL и Streaming, построению Data Warehouse и Data Lake.<br><br><em>Следите за анонсами и мероприятиями Mail.ru Cloud Solutions в <a href="http://t.me/k8s_mail">нашем Telegram-канале</a>.</em></p>	2023-11-12 11:55:18.953508+00	2023-11-12 11:59:48.379167+00
22	29b7c274-c628-4cc9-800c-90e217b172a4	2	Курс «PostgreSQL: replication, backup and observability». Старт 6 апреля	<p><img src="https://habrastorage.org/r/w1560/webt/af/h_/z-/afh_z-hy5zyrr5javpjmyp355ug.png" data-src="https://habrastorage.org/webt/af/h_/z-/afh_z-hy5zyrr5javpjmyp355ug.png"></p><p>Потеря данных или их недоступность — это всегда больно. А времени на поиск решений, анализ, тестирование идей по улучшению инфраструктуры не хватает, потому что надо поддерживать текущие процессы.</p><p>Мы собрали информацию и опыт в учебную программу, которая закроет три основных блока вопросов по работе с PostgreSQL.</p><p>Курс поможет сэкономить время на генерации идей, поиске информации. Рассмотрим архитектурные решения и вместе с преподавателем внедрим их в тестовой среде.</p>	<p>Спикер</p><p><strong>Иван Чувашов</strong>, ведущий инженер OKKO и администратор баз данных Southbridge</p><ul><li>Сертифицированный администратор PostgreSQL (PostgresPro, 10 уровень «Эксперт»);</li><li>13 лет опыта работы с базами данных, более 6 лет опыта работы архитектором БД и DBA;</li><li>Опыт поддержки технической инфраструктуры компании Окко (dev, preprod, prod) в части баз данных;</li><li>Опыт построения отказоустойчивых кластеров на базе СУБД PostgreSQL и GreenPlum 6x;</li><li>Постоянный докладчик на IT-конференциях.</li></ul><h3 id="raspisanie">Расписание</h3><p>Курс пройдёт в формате онлайн, по вторникам и четвергам в течение трёх недель: 6 и 8 апреля, 13 и 15 апреля, 20 и 22 апреля. Начало занятий в 19:00 по мск. Длительность занятия – 3 часа.</p><div class="spoiler" tabindex="0" role="button"> </div><div class="spoiler" tabindex="0" role="button"><strong class="spoiler_title">Программа</strong></div><p>Стоимость: 30 000 руб.</p>	2023-11-10 12:48:17.324352+00	2023-11-10 12:51:44.920579+00
56	8d06f824-5564-4829-afae-b7ab84c43f40	2	«Росатом» переносит огромную финансовую ИТ-систему с Oracle на Postgres Pro	<p>Финансовая ИТ-система «Росатома» для учета его казначейских операций, в контур которой входит свыше двухсот дочерних организаций госкорпорации мигрирует с американской СУБД Oracle на российскую Postgres Pro.<br><br><img src="https://habrastorage.org/r/w1560/webt/cb/ix/yp/cbixypxidx6rv6997odulbmekfy.jpeg" data-src="https://habrastorage.org/webt/cb/ix/yp/cbixypxidx6rv6997odulbmekfy.jpeg"></p><h3>От Oracle — к Postgres Pro</h3><p>Как выяснил CNews, масштабная ИТ-система «<a href="https://www.rosatom.ru/" rel="nofollow noopener noreferrer">Росатома</a>» «Расчетный центр корпорации» переедет с СУБД Oracle на российскую <a href="https://www.postgrespro.ru/about" rel="nofollow noopener noreferrer">Postgres Pro</a>. Она представляет собой отечественный коммерческий продукт, разработанный компанией Postgres Professional с использованием свободно распространяемой бесплатной СУБД PostgreSQL.<br><br>Замещение СУБД состоится в рамках проекта по модернизации «Расчетного центра корпорации». Система будет обновлена по итогам завершившегося тематического тендера «<a href="https://greenatom.ru/" rel="nofollow noopener noreferrer">Гринатома</a>» — главного ИТ-интегратора госкорпорации «Росатом».</p>	<h3>Некоторые подробности проекта</h3><p>Основной целью рассматриваемого проекта «Росатом» заявляет замещение иностранных ИТ-продуктов решениями отечественного производства — в соответствии с отдельным пунктом протокола заседания Совета по планированию текущей и проектной деятельности госкорпорации от 11 сентября 2019 г.<br><br>Из тендерной документации следует, что в периметре взаимодействия с системой находятся 242 организации атомной отрасли, включая филиалы госкорпорации.</p>	2023-11-12 12:11:25.923623+00	2023-11-12 12:13:13.161215+00
63	71f201d8-41c2-4dab-a9e5-d4ed17e313b0	2	Профессиональный Postgres	<p>Мы продолжаем публиковать видео и расшифровки лучших докладов с конференции <a href="https://pgconf.ru/2019/talks-and-tutorials"><strong>PGConf.Russia 2019</strong></a>. Доклад Олега Бартунова на тему «Профессиональный Postgres» открывал пленарную часть конференции. В нем раскрыта история СУБД Postgres, российский вклад в разработку, особенности архитектуры.<br><br>Предыдущие материалы этой серии: «Типичные ошибки при работе с PostgreSQL» Ивана Фролкова, части <a href="https://habr.com/ru/company/postgrespro/blog/442462/">1</a> и <a href="https://habr.com/ru/company/postgrespro/blog/443792/">2</a>.<br><br><img src="https://habrastorage.org/r/w1560/webt/6w/xq/rj/6wxqrjfovf4d8h2cwmpvuxm3ksy.jpeg" data-src="https://habrastorage.org/webt/6w/xq/rj/6wxqrjfovf4d8h2cwmpvuxm3ksy.jpeg"><br>Я буду рассказывать про профессиональный Postgres. Прошу не путать с компанией, которую я представляю сейчас — Postgres Professional.<br><img src="https://habrastorage.org/r/w1560/webt/nk/70/b-/nk70b-mwkpuybifhqv47feywluc.jpeg" data-src="https://habrastorage.org/webt/nk/70/b-/nk70b-mwkpuybifhqv47feywluc.jpeg"><br>Я действительно буду говорить о том, как Postgres, начинавшийся как любительская академическая разработка, стал профессиональным — таким, как мы его видим сейчас. Выскажу исключительно свое персональное мнение, оно не отражает мнение ни нашей компании, ни каких-либо групп.</p>	<p><img src="https://habrastorage.org/r/w1560/webt/dr/mn/am/drmnamtplm_a_e6v__bv1ajcye0.jpeg" data-src="https://habrastorage.org/webt/dr/mn/am/drmnamtplm_a_e6v__bv1ajcye0.jpeg">Так получилось, что я использую и занимаюсь Postgres не урывками, а непрерывно с 1995-го года по сегодняшний день. Вся его история прошла на моих глазах, я участник основных событий.</p><h3>История</h3><p>На этом слайде я кратко обозначил те проекты, в которых принимал участие. Многие из них вам знакомы. А историю Postgres начну сразу с картинки, которую я нарисовал много-много лет назад и потом ее только дорисовывал — число версий всё увеличивается и увеличивается. Она отражает эволюцию реляционных баз данных. Слева, если кто не знает, это <strong>Майкл Стоунбрейкер</strong>, которого называют отцом Postgres. Внизу наши первые «ядерные» разработчики. Человек сидящий справа — это Вадим Михеев из Красноярска, он был одним из первых core-разработчиков.<br><br>Начну рассказ о реляционной модели с IBM, которая внесла гигантский вклад в индустрию. Именно в IBM работал <strong>Эдгар Кодд</strong>, из ее недр появилась первая white paper по <strong>IBM System R</strong> — это была первая реляционная база. Майк Стоунбрейкер работал в то время в Бёркли. Он прочитал эту статью и вместе со своими ребятами загорелся: надо сделать базу данных.<br><img src="https://habrastorage.org/r/w1560/webt/j_/h3/km/j_h3kmxbh08ixh-dqehkcslzyfq.jpeg" data-src="https://habrastorage.org/webt/j_/h3/km/j_h3kmxbh08ixh-dqehkcslzyfq.jpeg">В те годы — в начале 70-х годов — как вы подозреваете, компьютеров было не много. На всё отделение Computer science университета Бёркли была одна PDP-11, и все студенты и преподаватели дрались за машинное время. В основном эта машина использовалась для расчетов. Я сам так работал, когда был молодым: отдаешь оператору задачу, он ее запускает. Но студенты и разработчики хотели интерактивной работы. Это была наша мечта — сидеть за пультом, вводить программы, отлаживать их. И когда Майк Стоунбрейкер со своими приятелями сделали первую базу, они назвали ее <strong>Ingres</strong> — INteractive Grafic REtrieval System. Люди не понимали: почему interactive? А это просто реализовалась мечта ее разработчиков. У них был консольный клиент, с помощью которого можно было работать с Ingres-ом. Он дал очень много нашей индустрии. Вы видите, сколько там стрелочек от Ingres? Это те базы данных, на которые он повлиял, которые шарили его код. У Майкла Стоунбрейкера было очень много учеников-разработчиков, которые ушли и разработали потом <strong>Sybase</strong> и <strong>MS SQL</strong>, <strong>NonStop SQL</strong>, <strong>Illustra</strong>, <strong>Informix</strong>.<br><br>Когда Ingres развился настолько, что стал интересным с коммерческой точки зрения, образовалась компания <strong>Illustra</strong> (это был 1992-й год), и код СУБД <strong>Illustra</strong> был куплен компанией <strong>Informix</strong>, которая была позже съедена <strong>IBM</strong>, и таким образом этот код ушел в <strong>DB2</strong>. Но что заинтересовало <strong>IBM</strong> в <strong>Ingres</strong>? В первую очередь расширяемость — те революционные идеи, которые Майкл Стоунбрейкер заложил с самого начала, думая о том, что база данных должна быть готова к решению любых бизнес-задач. А для этого нужно, чтобы в базу можно было добавить свои типы данных, access-методы и функции. Сейчас нам, постгресистам, это кажется естественным. В те годы это была революция. Именно со времен Ingres и Postgres эти фичи, эта функциональность стали де-факто стандартом для всех реляционных баз данных. Сейчас все базы данных имеют пользовательские функции, а когда Стоунбрейкер писал, что пользовательские функции нужны, компания <strong>Oracle</strong>, например, кричала о том, что это опасно, и что так делать нельзя потому, что пользователи могут навредить данным. Сейчас мы видим, что пользовательские функции существуют во всех базах данных, что можно делать свои агрегаты и типы данных.<br><img src="https://habrastorage.org/r/w1560/webt/hq/wo/gt/hqwogt5a8nn15iiot4na80usaug.jpeg" data-src="https://habrastorage.org/webt/hq/wo/gt/hqwogt5a8nn15iiot4na80usaug.jpeg">Postgres развивался как академическая разработка, а это значит: есть профессор, у него есть грант на разработку, студенты и аспиранты, которые с ним работают. Серьезную базу, готовую для продакшн, так сделать нельзя. Тем не менее в последнюю версию из Бёркли — <strong>Postgres95</strong> — уже был добавлен язык <strong>SQL</strong>. Студенты-разработчики в это время уже стали работать в компании Illustra, делали Informix и потеряли интерес к проекту. Они сказали: у нас есть Postgres95, забирайте его, кому нужно! Я это всё прекрасно помню потому, что сам был одним из тех, кто получил это письмо: был mailing list, а в нем меньше 400 человек подписчиков. Сообщество <strong>Postgres95</strong> начиналось с этих 400 человек. Мы все дружно проголосовали за то, что берем этот проект. У нас нашелся энтузиаст, который поднял CVS-сервер, и мы перетащили всё в Панаму, так как серверы были там.<br><img src="https://habrastorage.org/r/w1560/webt/b2/s-/ak/b2s-aki51mjp7675tjsg14lwbwu.jpeg" data-src="https://habrastorage.org/webt/b2/s-/ak/b2s-aki51mjp7675tjsg14lwbwu.jpeg">История <strong>PostgreSQL</strong> [дальше просто Postgres] начинается с версии 6.0, так как версии 1, 4, 5 были еще Postgres95. В 1997-м году 3 апреля появился наш логотип — слон. До этого у нас были разные животные. У меня на страничке, например, <a href="https://www.vertabelo.com/blog/notes-from-the-lab/the-history-of-slonik-the-postgresql-elephant-logo">долгое время был гепард</a>, намекавший, что Postgres очень быстрый. Потом в mailing list-е подняли вопрос: нашей большой базе данных нужно серьезное животное. И кто-то написал: давайте это будет слон. Все дружно проголосовали, потом наши ребята из Санкт-Петербурга нарисовали этот логотип. Изначально это был слон в алмазе — если поковыряетесь в машине времени, то увидите его. Слона выбрали потому, что у слонов очень хорошая память. Даже у Агаты Кристи есть такая повесть «Слоны могут помнить»: там слон очень мстительный, лет пятьдесят он помнил обиду, а потом задавил обидчика. Бриллиант потом откололи, рисунок векторизовали, и в результате получился вот этот слон. Так что это один из первых российских вкладов в Postgres.<br><a href="https://www.vertabelo.com/blog/notes-from-the-lab/the-history-of-slonik-the-postgresql-elephant-logo"><img src="https://habrastorage.org/getpro/habr/post_images/c61/243/5f7/c612435f71854bdb574bf4877f48e24b.gif" alt="Chitah" data-src="https://habrastorage.org/getpro/habr/post_images/c61/243/5f7/c612435f71854bdb574bf4877f48e24b.gif"></a> Гепарда сменил Слоник в бриллианте: <a href="https://www.vertabelo.com/blog/notes-from-the-lab/the-history-of-slonik-the-postgresql-elephant-logo"><img src="https://habrastorage.org/getpro/habr/post_images/293/a8c/3a7/293a8c3a74cc560443f24576f4f4db19.gif" alt="Elephant&amp;Diamond" data-src="https://habrastorage.org/getpro/habr/post_images/293/a8c/3a7/293a8c3a74cc560443f24576f4f4db19.gif"></a><br><br></p><h3>Этапы развития Postgres</h3><p>Первой задачей была стабилизация его работы. Сообщество переняло исходные коды академических разработчиков. Чего там только не было! Начали всё это перелопачивать, чтобы компилировалось прилично. Я выделил на этом слайде 1997-й год, версию 6.1 — в ней появилась интернационализация. Выделил не потому, что я сам это делал (это действительно был мой первый патч), а потому, что важный этап. Вы уже привыкли, что Postgres работает с любым языком, в любых локалях — во всем мире. А тогда он понимал только ASCII, то есть никаких 8-х битов, никаких европейских языков, никакого русского. Обнаружив это, я, следуя принципам open-source, просто взял и сделал поддержку локалей. И благодаря этой работе Postgres пошел в мир. После меня японец <strong>Тацуо Ишии</strong> [Tatsuo Ishii] сделал поддержку мультибайтных кодировок, и Postgres стал по-настоящему всемирным.<br><br>В 2005-м году была введена поддержка <strong>Windows</strong>. Я помню эти горячие споры, когда в mailing list-е это обсуждали. Все разработчики были нормальные люди, они работали под <strong>Unix</strong>. Вы вот сейчас хлопаете, и точно так же народ реагировал и тогда. И голосовал против. Это длилась годами. Более того, <strong>SRA Computers</strong> выпустили на несколько лет раньше свой <strong>Powergres</strong> — нативный порт на Windows. Но это было чисто японское изделие. Когда в 2005-м году в 8-й версии у нас появилась поддержка Windows, оказалось, что это сильный шаг: сообщество распухло. Появилось очень много людей и очень много глупых вопросов, но сообщество стало большое, мы схватили виндузовых пользователей.<br><br>В 2010-м году у нас появилась встроенная репликация. Это — боль. Я помню, сколько лет люди боролись за то, чтобы репликация была в Postgres. Сначала все говорили: нам не нужна репликация, это не дело базы данных, это дело внешних утилит. Если кто помнит, <strong>Slony</strong> сделал <strong>Ян Вик</strong> [Jan Wieck]. Кстати, «слони» тоже из русского языка пришли: Ян спросил меня, как будет по-русски «много слонов», и я ответил: «слоны». Вот он и сделал Slony. Эти слоны работали как логическая репликация на триггерах, настройка их была кошмаром — ветераны помнят. Более того, все долго слушали <strong>Тома Лейна</strong> [Tom Lane], который, помню, отчаянно кричал: зачем нам усложнять код репликацией, если это можно сделать снаружи базы? Но в результате встроенная репликация все-таки появилась. Это дало сразу колоссальное количество enterprise-пользователей потому, что до этого такие пользователи говорили: как нам вообще жить без репликации? Это невозможно!<br><br>В 2014-м году появился jsonb. Это работа моя, <strong>Федора Сигаева</strong> и <strong>Александра Короткова</strong>. И тоже народ кричал: зачем нам это нужно? Вообще, у нас уже был hstore, который мы сделали 2003-м году, а 2006-м он вошел в Postgres. Люди им прекрасно пользовались по всему миру, любили его, и, если в google набрать <strong>hstore</strong>, появлялось гигантское количество документов. Очень популярное расширение. И мы всячески пропагандировали идею неструктурированных данных в Postgres. С самого начала моей работы я как раз этим интересовался и, когда мы сделали <strong>jsonb</strong>, я получил массу писем с благодарностями и вопросами. А сообщество получило <strong>NoSQL</strong>-пользователей! До jsonb люди, зомбированые хайпом, шли в key-value базы данных. При этом они вынуждены были жертвовать целостностью, <strong>ACID</strong>-ностью. А мы им дали возможность, ничем не жертвуя, работать с их прекрасным json-ом. Комьюнити опять резко выросло.<br><br>В 2016-м году у нас появилось параллельное выполнение запросов. Если кто не знает, это, конечно, не для <strong>OLTP.</strong> Если у вас загруженная машина, то все ядра и так заняты. Параллельное выполнение запросов ценно для <strong>OLAP</strong>-пользователей. И они это оценили, то есть в сообщество начало прибывать и какое-то количество <strong>OLAP</strong>-юзеров.</p><p>Дальше шли накопительные процессы. В 2017-м году мы получили логическую репликацию и декларативное партицирование — это был тоже большой и серьезный шаг потому, что логическая репликация дала возможность делать очень и очень интересные системы, люди получили неограниченную свободу для своей фантазии и начали делать кластеры. С помощью декларативного партицирования стало возможно не вручную, а с помощью языка SQL создавать партиции.<br><br>В 2018-м году в 11-й версии мы получили <strong>JIT</strong>. Кто не знает, это Just In Time compiler: вы компилируете запросы, и это действительно может очень сильно ускорить выполнение. Это важно для ускорения медленных запросов потому, что быстрые запросы и так быстрые, а overhead на компиляцию все-таки существенный.<br><br>В 2019-м году самое основное, что мы ожидаем, это <strong>pluggable storage, API</strong> для того, чтобы разработчики могли создавать свои хранилища, один из примеров которых это <strong>zheap</strong> — хранилище, которое разрабатывает компания <strong>EnterpriseDB</strong>.<br><br>А вот и наша разработка: SQL/JSON. Я очень надеялся, что <strong>Саша Коротков</strong> закоммитит его до конференции, но там обнаружились какие-то проблемы, и мы теперь надеемся, что все-таки в этом году мы получим <strong>SQL/JSON</strong>. Люди ждут его уже два года [сейчас закоммичена значительная часть патча SQL/JSON: jsonpath, об этом написано подробно <a href="https://habr.com/ru/company/postgrespro/blog/448612//">здесь</a>].<br><img src="https://habrastorage.org/r/w1560/webt/sh/bp/c1/shbpc1e7xiywyepr3kxdygzujls.jpeg" data-src="https://habrastorage.org/webt/sh/bp/c1/shbpc1e7xiywyepr3kxdygzujls.jpeg">Дальше я перехожу к слайду, который показывает: Postgres — это универсальная база данных. Эту картинку можно изучать часами, рассказать кучу историй о возникновении компаний, о поглощении, о смерти компаний. Я начну с 2000-го года. Один из первых форков Postgres — IBM-овская <strong>Netezza</strong>. Вы только представьте себе: «Голубой гигант» взял код Postgres и соорудил для поддержки своих BI базу для OLAP!<br><br>Вот форк <strong>TelegraphCQ</strong>: уже в 2000-м году на основе Postgres в Бёркли люди делали стриминговую базу данных. Если кто не знает, это база данных, которая не интересуется самими данными, а интересуются их агрегатами. Сейчас очень много задач, где не нужно знать каждое значение, допустим, температуру в какой-то точке, а нужно среднее значение в данном регионе. И в TelegraphCQ взяли эту идею (возникшую тоже в Бёркли), одну из самых передовых идей того времени, и разработали базу на основе Postgres. Дальше она эволюционировала, и в 2008-м году на ее основе выпущен был уже коммерческий продукт — база <strong>TruCQ</strong>, сейчас ее владелец <strong>Cisco</strong>.<br><br>Я забыл сказать, что на этой страничке не все форки, их в раза в два больше. Я выбрал наиболее важные и интересные, чтобы не загромождать картинку. На <a href="https://wiki.postgresql.org/wiki/PostgreSQL_derived_databases">страничке в postgresql-вики</a> перечислены все форки. Кто знает опенсорсную базу данных, у которой было бы столько форков? Таких баз нет.<br><br>Postgres отличается от других баз не только своей функциональностью, но и тем, что у нее<br>очень интересное сообщество, оно нормально принимает форки. В мире опенсорс принято считать: я сделал форк потому, что обиделся — вы меня не поддержали, вот я и решил вести собственную разработку. В постгресовом мире появление форка означает: какие то люди или какая-то компания решили сделать некоторый прототип и проверить придуманную ими функциональность, поэкспериментировать. А если повезет, то и сделать коммерческую базу, которую можно будет продавать клиентам, предоставлять им сервис и так далее. При этом, как правило, разработчики всех этих форков возвращают свои наработки и патчи в сообщество. Продукт нашей компании тоже форк, и понятно, что мы кучу патчей вернули обратно в сообщество. В последней, 11-й версии мы вернули сообществу более 100 патчей. Если посмотрите в ее release notes, то там будет 25 фамилий наших сотрудников. Это нормальное поведение в сообществе. Мы используем комьюнити-версию и делаем свой форк для того, чтобы проверять свои идеи или давать клиентам функциональность раньше, чем сообщество созреет для ее принятия. Форки в Postgres-сообществе очень даже приветствуются.<br><br>Известная <strong>Vertica</strong> возникла из <strong>C-Store</strong> — тоже выросла из Postgres. Некоторые люди утверждают, что в Vertica вообще не было исходников из Postgres, а была только поддержка постгресового протокола. Но тем не менее принято причислять ее к постгресовым форкам.<br><br><strong>Greenplum</strong>. Сейчас вы можете скачать его и использовать как кластер. Он возник из <strong>Bizgres</strong> — массивно-параллельной базы данных. Потом она была куплена компанией Greenplum, стала и долго оставалась коммерческой. Но вы видите, что где-то в 2015-м году они поняли, что мир изменился: мир идет к открытым протоколам, к открытым сообществам, открытым базам данных. И открыли коды Greenplum. Сейчас они активно догоняют Postgres потому, что за это время отстали, конечно, очень сильно. Они отпочковались на 8.2, а сейчас говорят, что догнали 9.6.<br><br>Всеми нами любимый и нелюбимый <strong>Amazon</strong>. Вы знаете, как он возник. Это происходило на моих глазах. Была компания, был <strong>ParAccel</strong> с векторной обработкой, тоже на Postgres — продукт сообщества, открытый. В 2012-м году хитрый Amazon купил исходники и буквально через полгода объявил, что вот у нас в Amazon-е теперь есть <strong>RDS</strong>. Мы их тогда расспрашивали, они долго мялись, но потом все же выяснилось, что это Postgres. RDS до сих пор живет, и это один из самых популярных популярных сервисов Amazon-а, у них там порядка 7000 баз крутятся. Но они на этом не успокоились, и в 2010 появилась Amazon Aurora — Postgres 10 с переписанным сториджем, который вшит прямо в инфраструктуру Amazon, в их распределенное хранилище.<br><br>Посмотрите теперь на <strong>Teradata</strong>. Большая, старая добрая компания, которая занималась аналитикой, <strong>OLAP</strong>-ом. После «восьмерки» [PostgreSQL 8.0] возникла <strong>Aster Data</strong>.<br><br><strong>Hadoop</strong>: у нас Postgres на Hadoop — <strong>HadoopDB</strong>. Через некоторое время она стала закрытой базой <strong>Hadapt</strong>, принадлежащей <strong>Teradata</strong>. Если вы увидите Hadapt, знайте, что внутри там Postgres.<br><br>Очень интересная судьба у <strong>Citus</strong>. Все знают, что это распределенный Postgres для онлайн-аналитики. Он не поддерживает транзакции. <strong>Citus Data</strong> был стартапом, а Citus была с закрытыми исходниками — отдельная база данных. Через некоторое время люди поняли, что лучше жить с сообществом, открыться. И они очень много сделали, чтобы стать просто расширением (extension) Postgres. Плюс они начали делать бизнес уже на предоставлении своих облачных услуг. Вы все уже знаете: здесь написано <strong>MS Citus</strong> потому, что <strong>Microsoft</strong> их купил, буквально недели две назад. Наверное, для того, чтобы поддержать Postgres на своей <strong>Azure</strong>, то есть Microsoft тоже играет в эти игры. У них на Azure крутится Postgres, и команда разработчиков Citus присоединилась к разработчикам MS.<br><br>Вообще в последнее время процессы покупки постгресовых компаний пошли интенсивно. Буквально после того, как Microsoft купил Citus, другая постгресовая компания — <strong>credativ</strong> — купила компанию <strong>OmniTI</strong>, чтобы усилить свое присутствие на рынке. Это две достаточно известные, добротные компании. А компания Amazon купила компанию <strong>OpenSCG</strong>. Постгресовый мир сейчас меняется, и я дальше покажу, почему такой большой интерес к Postgres.<br><br>Нашумевшая <strong>TimescaleDB</strong> тоже была отдельной базой данных, но и она теперь расширение: вы берете Postgres и устанавливаете timescaledb как расширение и получаете базу данных, которая рвет всяческие специализированные базы данных.<br><br>Еще имеется Postgres XL, имеются кластеры, которые развиваются.<br><br>Сюда вот, в 2015-й год, я поставил наш форк: <strong>Postgres Pro</strong>. У нас есть <strong>Postgres Pro Enterprise</strong>, имеется сертифицированная версия, мы поддерживаем <strong>«1С»</strong> из коробки и мы признанны компанией <strong>«1С»</strong>. Если кто хочет попробовать Postgres Pro Enterprise, то можно бесплатно взять дистрибутив для тестирования, а если понадобится для работы, то вы можете его купить.<br><br>Мы сделали <strong>Credereum</strong> — прототип базы данных с поддержкой блокчейна. Теперь ждем, когда народ созреет для того, чтобы начать ее использовать.<br><br>Видите, какая большая и интересная картина. Я даже не говорю про <strong>Yahoo! Everest</strong> с колоночным хранением, с петабайтами данных в Yahoo! — это был 2008-й год. Они даже спонсировали нашу конференцию в Канаде, приезжали туда, у меня где-то даже майка оттуда имеется :)<br><br>Есть еще <strong>PipelineDB</strong>. Она тоже начиналась как база с закрытыми исходниками, а сейчас это тоже просто расширение. Мы видим, что Citus, TimescaleDB и PipelineDB это как бы отдельные базы данных, но при этом они существуют как расширения, то есть вы берете стандартный Postgres и компилите расширение. PipelineDB это продолжение идеи стримовых баз данных. Хотите работать со стримами? Берёте Postgres, берёте PipelineDB и можно работать.<br><br>Кроме того, есть расширения, которые позволяют работать с <strong>GPU</strong>. Видите заголовок? Я показал, что есть экосистема, которая охватывает большое количество разных типов данных и нагрузок. Поэтому мы говорим, что <strong>Postgres</strong> это универсальная база данных.</p><h3>Любимая народом база</h3><p><br><img src="https://habrastorage.org/r/w1560/webt/ga/ii/tn/gaiitn3if7znjvwoqfm1gtc-uj8.jpeg" data-src="https://habrastorage.org/webt/ga/ii/tn/gaiitn3if7znjvwoqfm1gtc-uj8.jpeg">На следующем слайде большие имена. Все самые известные облака мира поддерживают Postgres. У нас в России Postgres поддерживают большие госкомпании. Они пользуются им, а мы их обслуживаем в качестве наших клиентов.<br><br><img src="https://habrastorage.org/r/w1560/webt/uv/d5/tv/uvd5tvfqrvfy-qoxvf0sqizvx4c.jpeg" data-src="https://habrastorage.org/webt/uv/d5/tv/uvd5tvfqrvfy-qoxvf0sqizvx4c.jpeg"><br>Сейчас уже много расширений и много приложений, поэтому Postgres хорош как база данных, с которой начинается проект. Я всегда говорю стартаперам: ребята, не надо брать <strong>NoSQL</strong> базу данных. Я понимаю, что вам очень хочется, но начните с Postgres. Если вам не будет хватать чего-то, вы всегда сможете отцепить какой-нибудь сервис и отдать его специализированной базе данных. Кроме универсальности у Postgres есть еще одно достоинство: очень либеральная лицензия BSD, которая позволит делать что угодно со своей базой данных.<br><br><img src="https://habrastorage.org/r/w1560/webt/sh/bp/c1/shbpc1e7xiywyepr3kxdygzujls.jpeg" data-src="https://habrastorage.org/webt/sh/bp/c1/shbpc1e7xiywyepr3kxdygzujls.jpeg">Всё, что вы видите на этом слайде, доступно благодаря тому, что Postgres — расширяемая база данных, причем эта расширяемость заложена сразу, прямо в архитектуре базы данных. Когда Майкл Стоунбрейкер писал про Postgres в своей первой статье о нём (она написана им в 1984-м году, здесь я цитирую статью 1987-го года), он уже говорил о расширяемости как важнейшей составляющей функциональности базы данных. И это, как говорится, уже проверено временем. Можно добавлять свои функции, свои типы данных, операторы, индексные доступы (то есть оптимизированные access-методы), вы можете писать ваши процедуры на очень большом количестве языков. У нас имеется Foreign Data Wrapper (<strong>FDW</strong>), то есть интерфейсы для работы с разными хранилищами, файлами, можно коннектиться к <strong>Oracle</strong>, <strong>MySQL</strong> и другим базам.<br><br>Хочу привести пример из собственного личного опыта. Я работал с Postgres и, когда мне чего-то не хватало в Postgres, мы с коллегами просто добавляли эту функциональность. Нам нужно было работать, например, с русским языком, и мы сделали 8-битную локаль. Это был проект <strong>Rambler</strong>. Кстати, он был тогда в топ-5. <strong>Rambler</strong> был первым крупным мировым проектом, который встал на Postgres. Массивы в Postgres были с самого начала, но они были такие, что с ними ничего нельзя было делать, это была просто текстовая строчка, в которой хранились массивы. Мы добавили операторы, сделали индексы, и сейчас массивы это неотъемлемая часть функциональности Postgres, и многие из вас используют их, совершенно не задумываясь о том, насколько они быстро работают — и это нормально. Раньше говорили, что массивы это уже не традиционная реляционная модель, не удовлетворяет классическим нормальным формам. Сейчас люди уже привыкли пользоваться массивами.<br><img src="https://habrastorage.org/r/w1560/webt/2r/av/dm/2ravdm7lcn2kcxit1am0jkt-qqw.jpeg" data-src="https://habrastorage.org/webt/2r/av/dm/2ravdm7lcn2kcxit1am0jkt-qqw.jpeg">Когда нам понадобился полнотекстовый поиск, мы его сделали. Когда нам потребовалось хранить данные разной природы, мы сделали расширение hstore, и многие люди стали его использовать: он давал возможность строить гибкие схемы БД, чтобы можно было диплоиться раньше и быстрее. Мы сделали <strong>GIN</strong>-индекс, чтобы полнотекстовый поиск работал быстро. Сделали триграммы (<strong>pg_trgm</strong>). Сделали NoSQL. И всё это на моей памяти, всё из собственных нужд.<br><img src="https://habrastorage.org/r/w1560/webt/se/gn/xo/segnxobdbjnlf2azoqbghdjfimi.jpeg" data-src="https://habrastorage.org/webt/se/gn/xo/segnxobdbjnlf2azoqbghdjfimi.jpeg">Расширяемость как раз и делает Postgres уникальной базой, универсальной базой данных, с которой можно начинать работать и не бояться, что вы останетесь без поддержки. Посмотрите, сколько у нас здесь людей — это уже рынок! Несмотря на то, что сейчас хайп — графовые базы данных, документные базы, time series и так далее, — посмотрите: большинство по-прежнему использует реляционные базы данных. Они доминируют, это 75% рынка баз данных, а остальные — это экзотические базы данных, мелочь по сравнению с реляционными.<br><img src="https://habrastorage.org/r/w1560/webt/xj/dk/pz/xjdkpzm_y2ja43ci3ona1dd7-yu.jpeg" data-src="https://habrastorage.org/webt/xj/dk/pz/xjdkpzm_y2ja43ci3ona1dd7-yu.jpeg">Если вы посмотрите соотношение баз данных open source с коммерческими, то, по<br>данным <strong>DB-Engines</strong>, мы увидим, что количество баз open source почти равно числу коммерческих баз. И мы видим, что open source базы данных (синяя линия) растут, а коммерческие (красная) падают. Это направление развития всего ИТ-сообщества, направление к открытости. Сейчас, конечно, неприлично ссылаться на <strong>Gartner</strong>, но я всё равно скажу: они предсказывают, что к 2022-му году 70% будут использовать открытые базы данных и до 50% существующих систем будут мигрировать на open source.<br><br>Посмотрите на вот эту пузомерку: мы видим, что Postgres названа базой данных 2018-го года. В прошлом году она тоже была 1-ая по независимым оценкам экспертов DB-Engines. Рэнкинг показывает, что Postgres действительно впереди планеты всей. Он находится в абсолютном исчислении на 4-м месте, но посмотрите, как он растет. Уверенно, хорошо. На слайде это синяя линия. Остальные — MySQL, Oracle, MS SQL — либо балансирует на своем уровне, либо начинает загибаться.<br><img src="https://habrastorage.org/r/w1560/webt/d1/j8/xy/d1j8xy2fib6132yvqww99dfwmpk.jpeg" data-src="https://habrastorage.org/webt/d1/j8/xy/d1j8xy2fib6132yvqww99dfwmpk.jpeg"><strong>Hacker news</strong> — все вы, наверное, читаете его или <strong>Y Combinator</strong> — там периодически проводят опросы, там компании публикуют свои вакансии, и с некоторых пор ведут статистику. Вы видите, что начиная где-то с 2014-го года, Postgres опережает всех. Был 1-м MySQL, но Postgres потихоньку вырос, и теперь среди всего хакерского сообщества (в хорошем смысле слова) он тоже превалирует и растет дальше.<br><img src="https://habrastorage.org/r/w1560/webt/iq/iy/t5/iqiyt58ooc-7x-fn7hu7oz1k_y4.jpeg" data-src="https://habrastorage.org/webt/iq/iy/t5/iqiyt58ooc-7x-fn7hu7oz1k_y4.jpeg"><br>В <strong>Stack Overflow</strong> тоже каждый год проводят опросы. По <strong>most used</strong> наш <strong>Postgres</strong> находится на хорошем, третьем месте. По <strong>most loved</strong> — на втором. Это любимая база данных. <strong>Redis</strong> это не реляционная база данных, а из реляционных Postgres самая любимая. Я не привел здесь картинку <strong>most dreaded</strong> — самая ужасная база данных, но вы, наверно догадываетесь, кто на первом месте. «База икс», как ее любят называть в России.<br><img src="https://habrastorage.org/r/w1560/webt/pl/eo/e6/pleoe6k3jg8sgfkhtzhfhnwpodo.jpeg" data-src="https://habrastorage.org/webt/pl/eo/e6/pleoe6k3jg8sgfkhtzhfhnwpodo.jpeg"><br>Есть обзор и по России, опрос на всеми нами уважаемой конференции <strong>HighLoad++</strong>. Проводился не нами, его делал <strong>Олег Бунин</strong>. Получилось: в России Postgres база данных №1.<br><br><img src="https://habrastorage.org/r/w1560/webt/cp/i-/ji/cpi-jisef4l2pucvjinntmuyveg.jpeg" data-src="https://habrastorage.org/webt/cp/i-/ji/cpi-jisef4l2pucvjinntmuyveg.jpeg"><br>Мы второй раз просим <strong>HH.ru</strong>, чтобы они с нами делились статистикой по вакансиям Postgres. 9 лет назад Postgres отставал от Oracle в 10 раз, все кричали: давайте нам ораклистов. И мы видим, что в прошлом году мы сравнялись, а дальше в 2018-м году был рост. И если вы волнуетесь о том, где найти работу, то смотрите: 2 тысячи вакансий на HH.ru это Postgres. Не волнуйтесь, работы хватит.<br><br><img src="https://habrastorage.org/r/w1560/webt/br/hg/pp/brhgppn2yfvqgga0jt7owf6cueu.jpeg" data-src="https://habrastorage.org/webt/br/hg/pp/brhgppn2yfvqgga0jt7owf6cueu.jpeg"><br><br>Для того чтобы было лучше видно, я сделал картинку, где показал вакансии Postgres относительно вакансий Oracle. Было меньше единички, начиная с 2018-го они уже вровень, и сейчас Postgres-а уже стало чуть-чуть больше. Пока немного удручает, что абсолютное число вакансий Oracle тоже растет, чего в принципе не должно быть. Но, как говорится, сидим у берега реки и смотрим: когда же мимо проплывет труп врага. Мы просто делаем свое дело.<br><br><img src="https://habrastorage.org/r/w1560/webt/s1/tj/gn/s1tjgnnoj72q_2bttfadjwreayo.jpeg" data-src="https://habrastorage.org/webt/s1/tj/gn/s1tjgnnoj72q_2bttfadjwreayo.jpeg"><br><br></p><h3>Российское сообщество Postgres</h3><p>Это самое организованное сообщество в России, я больше таких не встречал. Очень много ресурсов, чатов, где мы все общаемся по делу. Мы проводим конференции — две большие конференции: в Санкт-Петербурге и в Москве, квартирники, мы участвуем во всех крупных международных конференциях, проводим курсы.<br><br><img src="https://habrastorage.org/r/w1560/webt/vr/me/yw/vrmeyw6fb7edzyg-1q-fpw4kg94.jpeg" data-src="https://habrastorage.org/webt/vr/me/yw/vrmeyw6fb7edzyg-1q-fpw4kg94.jpeg">Фактически это курсы сообщества. Их подготовила наша компания, но они свободно доступны любому из вас, смотрите на youtube наш канал или зайдите на наш сайт в раздел «Образование», там для свободного скачивания лежат курсы <strong>DBA1</strong>, <strong>DBA2</strong>, <strong>DBA3</strong>, девелоперские курсы.<br><br>А сейчас мы запускаем сертификацию — это то, что просят компании, они хотят иметь сертифицированных специалистов. И работодатель будет знать: вы сертифицированный специалист.<br><img src="https://habrastorage.org/r/w1560/webt/fn/ul/cn/fnulcnzm8ernunmrxufan6wsye4.jpeg" data-src="https://habrastorage.org/webt/fn/ul/cn/fnulcnzm8ernunmrxufan6wsye4.jpeg">Очень часто спрашивают: а насколько Postgres российский? Вопрос немного неправильно поставлен: Postgres — международный. Но о российском флаге я немного скажу. Вы видите на слайде, что сделал <strong>Вадим Михеев</strong>. Тем, кто знает Postgres, понятно, что для этой базы значат <strong>MVCC</strong>, <strong>WAL</strong>, <strong>VACUUM</strong> и так далее. Это всё российский вклад. Сейчас ведущих разработчиков Postgres трое, из них двое — коммиттеры. На слайде вы видите, что сделано довольно много. Если смотреть мажорные фичи из release notes, то вы увидите наш вклад. Российский вклад есть и достаточно существенный. Мы работали с самого начала и продолжаем работать с сообществом — уже на уровне кампании.<br><br><img src="https://habrastorage.org/r/w1560/webt/-_/pb/0o/-_pb0os-qj-9sqqelamopxrtc34.jpeg" data-src="https://habrastorage.org/webt/-_/pb/0o/-_pb0os-qj-9sqqelamopxrtc34.jpeg"><br><br>А еще вклад компании — это книжки. У нас имеются 2 университетских курса по Postgres. Вы можете пойти в магазин и эти книжки купить, вы можете преподавать по этим курсам, сдавать экзамены и так далее. У нас имеются книжки для начинающих, которые раздаются, в том числе здесь. Очень полезная хорошая книжка. Мы ее даже перевели на английский язык.</p><h3>Профессиональный Postgres</h3><p>Перейдем к основному. Академический Postgres, когда он начинался, был рассчитан на несколько десятков пользователей. Комьюнити Postgres95 было меньше 400 человек. Cообщество состояло в основном из разработчиков и было еще немного пользователей. При этом — интересная деталь — разработчики были, в основном, и заказчиками, и исполнителями. Например, когда мне это было нужно, я разрабатывал для себя и, одновременно, делился со всеми. То есть комьюнити разрабатывало для комьюнити.<br><br>Начиная с 2000-го года, чуть раньше, начали появляться первые постгресовые компании: <strong>GreatBridge</strong>, <strong>2ndQuadrant</strong>, <strong>EDB</strong>. Они уже нанимали full-time разработчиков, которые работали на сообщество. Появились первые энтерпрайзные форки и первые энтерпрайзные кастомеры. Привело это к тому, что к 2015-му году основное количество — да практически все ведущие разработчики — уже были организованы в какие-то компании. В 2015-м году образовалась наша компания: мы были последними свободными фрилансерами-разработчиками. Сейчас таких практически не осталось. Постгресовое сообщество изменилась, стало энтерпрайзным, и теперь уже эти компании драйвят разработку. Это хорошо потому, что эти компании проводят то, что необходимо энтерпрайзу. Сообщество является тормозом в хорошем смысле: оно тестирует фичи, осуждает или принимает новые фичи, оно объединяет всех нас. А Postgres стал <strong>enterprise ready</strong>, его с удовольствием используют большие компании, он стал профессиональным.<br><br><img src="https://habrastorage.org/r/w1560/webt/o2/e5/xo/o2e5xoivdog37jlibahc3ixfx8c.jpeg" data-src="https://habrastorage.org/webt/o2/e5/xo/o2e5xoivdog37jlibahc3ixfx8c.jpeg"><br>Этот слайд про будущее, как я его вижу. С появлением <strong>pluggable storage</strong> будут появляться новые хранилища: <strong>append-only</strong>, <strong>read-only</strong>, <strong>column storage</strong> — что хотите (я вот, например, мечтаю о паркетном). Будет поддержка векторных операций. Сегодня, кстати, будет доклад про них. Будет поддерживаться блокчейн. Никуда от этого не деться, раз мы переходим на цифровую экономику, на безбумажные технологии. Нужно будет использовать электронные подписи и нужно будет уметь удостоверять вашу базу данных, убеждаться, что никто ничего не подменил, и блокчейн для этого очень хорошо подходит.<br><br><img src="https://habrastorage.org/r/w1560/webt/hi/o4/ew/hio4ewlug7ngx1u_pkdfxnookea.jpeg" data-src="https://habrastorage.org/webt/hi/o4/ew/hio4ewlug7ngx1u_pkdfxnookea.jpeg"><br><img src="https://habrastorage.org/r/w1560/webt/dw/pj/wu/dwpjwu8rleax8s4tiwzwsenz6dq.jpeg" data-src="https://habrastorage.org/webt/dw/pj/wu/dwpjwu8rleax8s4tiwzwsenz6dq.jpeg">Дальше: <strong>адаптивный Postgres</strong>. Это немного грустная для вас тема, но она еще довольно далека от вас. Дело в том, что DBA, вообще говоря, достаточно дорогой ресурс, и скоро базы данных не будут нуждаться в них. Базы будут достаточно умными и сами себя будут конфигурировать и подстраивать. Но это будет еще лет через десять, наверное. У нас еще много времени.<br><br><img src="https://habrastorage.org/r/w1560/webt/is/7q/do/is7qdodq1poxskgyqicnnx36qnu.jpeg" data-src="https://habrastorage.org/webt/is/7q/do/is7qdodq1poxskgyqicnnx36qnu.jpeg"><br>И понятно, что в Postgres будет нативная поддержка клаудов, облачных хранилищ — без этого нам просто не выжить. И, конечно, вот он, последний слайд:<br><br>ВСЁ, ЧТО ВАМ НАДО, ЭТО — POSTGRES!<br><img src="https://habrastorage.org/r/w1560/webt/nk/jf/pp/nkjfppakwrrywr1a8uhbzqskqgk.jpeg" data-src="https://habrastorage.org/webt/nk/jf/pp/nkjfppakwrrywr1a8uhbzqskqgk.jpeg">Спасибо за внимание.</p>	2023-11-12 12:44:57.215764+00	2023-11-12 12:46:01.299626+00
57	e114d2e3-e6df-4677-ae09-4b6da6f54477	2	Postgres Professional откажется от поддержки Windows в 15-х версиях Postgres Pro Standard и Postgres Pro Enterprise	<figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/6e3/6f8/d92/6e36f8d929556160edd123c1b6b4b120.png" width="1220" height="586" data-src="https://habrastorage.org/getpro/habr/upload_files/6e3/6f8/d92/6e36f8d929556160edd123c1b6b4b120.png"><figcaption></figcaption></figure><p>Компания Postgres Professional <a href="https://postgrespro.ru/blog/news/5969697" rel="noopener noreferrer nofollow">собирается снижать</a> степень поддержки ОС Windows в своих продуктах. В готовящихся к выпуску 15-х версиях <a href="https://postgrespro.ru/products/postgrespro/standard" rel="noopener noreferrer nofollow">Postgres Pro Standard</a> и <a href="https://postgrespro.ru/products/postgrespro/enterprise" rel="noopener noreferrer nofollow">Postgres Pro Enterprise</a> поддержки Windows уже не будет. Предыдущие версии компания будет обслуживать в полном объёме вплоть до окончания срока поддержки.</p>	<blockquote><p><em>«Мы решили постепенно отказываться от обслуживания наименее популярных операционных систем для увеличения скорости выпуска обновлений наших продуктов. Эти изменения ни в коем случае не затронут текущих пользователей более ранних версий. Для них мы будем выпускать обновления и осуществлять поддержку в полном объёме», — указал Иван Панченко, заместитель генерального директора Postgres Professional.</em></p></blockquote><p>Компания указала, что сборки PostgreSQL и PostgreSQL для 1С для Windows планируют выпускать в штатном режиме.</p>	2023-11-12 12:19:56.062114+00	2023-11-12 12:19:56.062114+00
59	2a50a70a-02d0-41f2-aa12-092963046b92	2	На облачной платформе VK Cloud доступна СУБД Postgres Pro Enterprise	<p><img src="https://habrastorage.org/r/w1560/webt/wp/ww/r3/wpwwr3v1pra89_vthotphggdj30.png" data-src="https://habrastorage.org/webt/wp/ww/r3/wpwwr3v1pra89_vthotphggdj30.png">VK Cloud расширила набор облачных сервисов для крупного бизнеса. На платформе теперь доступна высокопроизводительная система управления базами данных <a href="https://mcs.mail.ru/databases/postgres-pro?utm_source=habr&amp;utm_medium=referral&amp;utm_campaign=2022-09-20-postgres-pro-enterprise">Postgres Pro Enterprise</a>. Решение поддерживает высокие нагрузки и параллельную работу до 10 тысяч пользователей, позволяет гибко управлять данными и оптимизировать вычислительные мощности компании.</p>	<p>Применение облачной версии Postgres Pro Enterprise позволит создать надежное и масштабируемое хранилище данных без капитальных затрат на ИТ-инфраструктуру. В VK Cloud реализована посекундная тарификация СУБД, а вычислительные мощности для системы можно расширить или отключить парой кликов. Postgres Pro Enterprise легко развернуть и начать использовать в публичном и частном облаке.<br><br>СУБД Postgres Pro Enterprise разработана для проектов, где необходим инструментарий для работы с большими объемами данных в условиях, требующих высокой производительности и надежности. Оптимизированный формат хранения данных, инструменты проверки целостности базы и резервное копирование сохранят информацию без остановки работы системы, даже если один из узлов выйдет из строя. Кроме того, в Postgres Pro Enterprise реализованы продвинутые механизмы разграничения прав пользователей: доступом к данным можно управлять на уровне отдельных записей.<br><br>Предприятия, которые эксплуатируют системы на базе продуктов Postgres Professional могут разместить среду для разработки и тестирования в VK Cloud и оценить возможности облачной СУБД. Компании также могут перенести в облако ERP-системы: развернуть их в VK Cloud и использовать управляемую СУБД Postgres Pro Enterprise. В частности, специальную версию Postgres Pro Enterprise для 1С.<br><br><a href="https://mcs.mail.ru/databases/postgres-pro?utm_source=habr&amp;utm_medium=referral&amp;utm_campaign=2022-09-20-postgres-pro-enterprise">Postgres Pro Enterprise</a> внесена в Единый реестр российских программ и баз данных Минцифры России. СУБД совместима с операционной системой Astra Linux, что помогает оперативно развернуть в VK Cloud решение с соблюдением всех требований по работе с отечественным ПО и персональными данными. Подключиться к Postgres Pro Enterprise могут пользователи, зарегистрированные на платформе VK Cloud.</p>	2023-11-12 12:26:13.289322+00	2023-11-12 12:26:13.289322+00
60	b3fca04b-e6fe-4b93-899a-c70da17c88b5	2	Вышла СУБД Postgres Pro Enterprise 15.1.1	<figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/c4b/616/fb4/c4b616fb497895e22bfd8d6efcd67bf6.jpg" width="1200" height="840" data-src="https://habrastorage.org/getpro/habr/upload_files/c4b/616/fb4/c4b616fb497895e22bfd8d6efcd67bf6.jpg"><figcaption></figcaption></figure><p>Компания Postgres Professional выпустила новую версию системы управления базами данных (СУБД) для высоконагруженных систем Postgres Pro Enterprise 15.1.1. Она включает возможности PostgreSQL 15 и Postgres Pro Standard 15, а также новые разработки Postgres Professional. </p>	<p>В компании <a href="https://postgrespro.ru/blog/news/5969951" rel="noopener noreferrer nofollow">отмечают</a>, что при создании новой версии учитывалась потребность пользователей в упрощении процесса перехода на отечественные СУБД. Так, в ней реализована основная функциональность пакетов (наборов функций и процедур) СУБД Oracle, что упрощает миграцию кода на языке PL/SQL при переходе с Oracle на Postgres. С технической точки зрения поддержка пакетов представляет собой расширение синтаксиса языка PL/pgSQL (с небольшими дополнениями в ядре СУБД), благодаря которому реализуется функциональный аналог пакетов Oracle и вводится ряд дополнительных команд для работы с ними.</p><p>Также появилась возможность передачи позиционных параметров в скрипт в psql, что позволит создавать более гибкие и универсальные shell-скрипты для работы с СУБД. Это также упростит адаптацию SQL-скриптов при миграции с СУБД Oracle.</p><p>Для защиты данных в Postgres Pro Enterprise 15.1.1 включено маскирующее расширение pgpro_anonymizer. </p><p>«Модуль маскирования (обфускации) данных добавлен в Postgres Pro Enterprise 15.1.1 в целях обеспечения безопасности хранимых данных в системах корпоративного уровня, а также для создания анонимизированных копий БД для использования в средах тестирования и разработки. Пользователям pgpro_anonymizer будет доступно статическое и динамическое маскирование, а также создание маскированного дампа», — поясняют в компании. В дальнейшем функциональность модуля планируется расширить.</p><p>Обновился инструментарий для резервного копирования и восстановления данных: на основе pg_probackup разработана новая утилита резервного копирования для корпоративных сред pg_probackup Enterprise. Её возможности включают новую подсистему ввода-вывода, повышающую производительность; поддержку протокола S3 для хранения данных в частных и общедоступных облаках; обеспечение совместимости CFS (компрессии данных) с механизмом создания инкрементальных резервных копий; поддержку всех режимов создания резервных копий (DELTA, PAGE и PTRACK), а также алгоритмов сжатия LZ4 и ZSTD.</p><p>Среди других функций:</p><p>• новые функции обработки JSON из стандарта SQL:2016 в дополнение к ранее реализованному языку JSONPATH;<br>• готовность к работе с расширением TimescaleDB (после официального объявления его разработчиком о поддержке PostgreSQL 15);<br>• добавление модуля tds_fdw для упрощения миграции с MS SQL Server;<br>• официальная поддержка процессоров «Эльбрус».</p><p>Компания напоминает, что в версиях СУБД Postgres Pro редакций Standard и Enterprise начиная с 15-й прекращена поддержка ОС Windows. Postgres Pro Enterprise 15.1.1 также её не поддерживает.</p><p>Полный список обновлений можно увидеть в <a href="https://postgrespro.ru/docs/enterprise/15/release-proee-15-1-1" rel="noopener noreferrer nofollow">замечаниях</a> к выпуску.</p>	2023-11-12 12:28:09.197818+00	2023-11-12 12:28:09.197818+00
61	f3305b04-85d7-4e0b-9daf-5b89c138a705	2	Postgres Professional выпустила обновлённое издание книги «PostgreSQL 15 изнутри»	<p><img src="https://habrastorage.org/r/w1560/webt/bm/dk/fv/bmdkfvkhkq5nsmtviksg8xsa-t8.jpeg" data-src="https://habrastorage.org/webt/bm/dk/fv/bmdkfvkhkq5nsmtviksg8xsa-t8.jpeg"><br><br>Компания-разработчик российской СУБД Postgres Professional <a href="https://postgrespro.ru/blog/news/5969921" rel="nofollow noopener noreferrer">выпустила</a> обновлённое издание книги «PostgreSQL 15 изнутри». Электронная версия учебника находится в <a href="https://edu.postgrespro.ru/postgresql_internals-15.pdf" rel="nofollow noopener noreferrer">свободном доступе</a>.</p>	<blockquote>«Эта книга для тех, кого не устраивает работа с базой данных как с черным ящиком. Если вы любознательны, не довольствуетесь авторитетными советами и хотите во всем разобраться сами — нам по пути.<br><br>Я ориентируюсь на читателей, имеющих некоторый опыт использования PostgreSQL и хотя бы в общих чертах представляющих себе, что к чему. Надеюсь, что книга будет полезной и тем, кто хорошо знаком с устройством другой СУБД, но переходит на PostgreSQL и хочет разобраться в отличиях.<br><br>Здесь вы не найдете готовых рецептов. Ведь на все случаи жизни их все равно не хватит, а понимание внутренней механики позволяет критически переосмысливать чужой опыт и делать собственные выводы. Именно поэтому я объясняю, как что устроено, возможно даже более подробно, чем на первый взгляд может показаться практичным.<br><br>Большая часть сведений будет актуальна еще довольно долго, но отдельные детали устаревают с неумолимой быстротой — отсюда и номер версии на обложке. Обдумывайте, экспериментируйте, проверяйте. В PostgreSQL для этого есть все инструменты, и я старался показать, как ими пользоваться.<br><br>В настоящем издании учтены замечания читателей и исправлены опечатки, а также отражены изменения, произошедшие в версии PostgreSQL 15»,<br><br>— написал в предисловии автор книги директор по разработке образовательных программ Postgres Professional Егор Рогов.</blockquote><p>Также Postgres Professional <a href="https://postgrespro.ru/docs/postgresql/15/index?lang=ru" rel="nofollow noopener noreferrer">обновила</a> локализованную документацию к PostgreSQL 15.1.<br><br>Ранее Postgres Professional <a href="https://postgrespro.ru/education/books" rel="nofollow noopener noreferrer">выложила</a> в свободный доступ книги, учебники и брошюры по работе с PostgreSQL. На сайте компании доступны для свободного скачивания в формате pdf следующие книги:</p><ul><li>«<a href="https://postgrespro.ru/education/books/introbook" rel="nofollow noopener noreferrer">Postgres: первое знакомство</a>» — брошюра по базовым сведениям, содержащая краткий экскурс в историю PostgreSQL и инструкции для начала работы;</li><li>«<a href="https://postgrespro.ru/education/books/sqlprimer" rel="nofollow noopener noreferrer">PostgreSQL. Основы языка SQL</a>» — учебник для тех, кто хочет познакомиться с языком SQL и его спецификой в PostgreSQL;</li><li>«<a href="https://postgrespro.ru/education/books/dbtech" rel="nofollow noopener noreferrer">Основы технологий баз данных</a>» — пособие для студентов, включающее теорию баз данных, методы и алгоритмы, применяемые для реализации СУБД, и особенности PostgreSQL. Курс рассчитан на студентов вузов, имеющих базовую подготовку по программированию, а также разработчиков баз данных и СУБД. Во втором издании книги добавлено подробное рассмотрение структур хранения, методов выполнения и оптимизации запросов, средств поддержки согласованности и надежности, создания параллельных и распределенных систем баз данных и других вопросов.</li></ul>	2023-11-12 12:30:20.431957+00	2023-11-12 12:30:20.431957+00
62	47502042-00ad-423a-96ee-c023bb637579	2	Postgres в ретроспективе	<p><em>Предлагаем вашему вниманию перевод статьи <strong>Джозефа Хеллерштейна «Looking Back at Postgres»</strong>, опубликованной в соответствии с международной лицензией Creative Commons «С указанием авторства» версии 4.0 (CC-BY 4.0). Авторы оставляют за собой право распространять эту работу на личных и корпоративных веб-сайтах с надлежащей ссылкой на источник.</em><br><br><em>Перевод выполнен Еленой Индрупской. От себя добавлю, что «программист, который отчаянно хотел построить систему с многоверсионностью» — судя по всему, Вадим Михеев, ну а «добровольцев из России», переписавших GiST, мы все хорошо знаем.</em></p><h3>Аннотация</h3><p>Это воспоминание о проекте Postgres, выполняемом в Калифорнийском университете в Беркли и возглавляемом Майком Стоунбрейкером (Mike Stonebraker) с середины 1980-х до середины 1990-х годов. В качестве одного из многих личных и исторических воспоминаний, эта статья была запрошена для книги [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#bro19">Bro19</a>], посвященной награждению Стоунбрейкера премией Тьюринга. Поэтому в центре внимания статьи — руководящая роль Стоунбрейкера и его мысли о дизайне. Но Стоунбрейкер никогда не был программистом и не мешал своей команде разработчиков. Кодовая база Postgres была работой команды блестящих студентов и эпизодически—штатных университетских программистов, которые имели немного больше опыта (и только немного большую зарплату), чем студенты. Мне посчастливилось присоединиться к этой команде в качестве студента в последние годы проекта. Я получил полезный материал для этой статьи от некоторых более старших студентов, занятых в проекте, но любые ошибки или упущения являются моими. Если вы заметили какие-либо из них, пожалуйста, свяжитесь со мной, и я постараюсь их исправить.</p>	<h1>1. Введение</h1><p>Postgres был самым амбициозным проектом Майкла Стоунбрейкера — его серьезной попыткой создать универсальную систему баз данных. Продолжаясь десятилетие, проект породил больше статей, кандидатов наук, профессоров и компаний, чем какая-либо еще деятельность Стоунбрейкера. Проект также охватывал больше технической области, чем любая другая система, которую он построил. Несмотря на риск, присущий такому масштабу, Postgres также стал самым успешным программным артефактом, который вышел из исследовательских групп Стоунбрейкера, и его основным вкладом в открытый исходный код. Это пример «второй системы» [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#Bro75">Bro75</a>], которая имела успех. На момент написания статьи, т. е. более тридцати лет с начала проекта, система PostgreSQL с открытым исходным кодом является в мире самой популярной независимой системой баз данных с открытым исходным кодом и четвертой по популярности системой баз данных. Между тем компании, созданные из Postgres, произвели в общей сложности более 2,6 млрд. долл. США (в стоимости приобретения). По любым меркам видение Postgres Стоунбрейкера имело огромный продолжительный резонанс.</p><h2>1.1. Предыстория</h2><p>Стоунбрейкер имел огромный успех в начале карьеры с исследовательским проектом Ingres в Беркли [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#SHWK76">SHWK76</a>] и последующим стартапом, который он основал вместе с Ларри Роу (Larry Rowe) и Юджином Вонгом (Eugene Wong): Relational Technology, Inc. (RTI).<br><br>По мере развития RTI в начале 1980-х годов Стоунбрейкер начал работать над поддержкой в СУБД типов данных, выходящих за рамки традиционных строк и столбцов исходной реляционной модели Кодда (Edgar Frank Codd). Мотивирующим примером в то время была потребность поддержки базами данных инструментов автоматизированного проектирования (САПР) для микроэлектронной промышленности. В статье 1983 г. Стоунбрейкер и студенты Брэд Рубенштейн (Brad Rubenstein) и Антонин Гуттман (Antonin Guttman) объяснили, насколько эта отрасль нуждается в поддержке «новых типов данных, таких как многоугольники, прямоугольники, текстовые строки и т. д.», «эффективного пространственного поиска», «сложных ограничений целостности», а также «проектных иерархий и множественных представлений» в одних и тех же физических конструкциях [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#SRG83">SRG83</a>]. Имея такую мотивацию, группа начала работу над индексированием (в том числе с помощью R-деревьев Гуттмана для пространственного индексирования [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#Gut84">Gut84</a>]) и над добавлением абстрактных типов данных (АТД) в систему реляционных баз данных. В то время АТД были популярной новой конструкцией языков программирования, которая была впервые введена Барбарой Лисков (Barbara Liskov), впоследствии лауреатом премии Тьюринга, и исследована в прикладном программировании баз данных новым сотрудником Стоунбрейкера — Ларри Роу. В статье в SIGMOD Record в 1983 г. [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#OFS83">OFS83</a>] Стоунбрейкер и студенты Джеймс Онг (James Ong) и Деннис Фогг (Dennis Fogg) описывают исследование этого понятия в расширении Ingres, названном ADT-Ingres, в которое были включены многие концепции представления, изученные более глубоко и с лучшей системной поддержкой в Postgres.</p><h1>2. Postgres: общие сведения</h1><p>Как следует из названия, Postgres это «Post-Ingres»: система, предназначенная для того, чтобы взять то, что могла делать Ingres, и выйти за ее рамки. Отличительным признаком Postgres было введение того, что он в конечном итоге назвал объектно-реляционными свойствами базы данных: поддержка концепции объектно-ориентированного программирования в модели данных и декларативного языка запросов системы баз данных. Но Стоунбрейкер также задумал решить в Postgres ряд других независимых от объектно-ориентированной поддержки технологических проблем, таких как правила активной базы данных, версионные данные, третичное хранилище и параллелизм.<br><br>Две статьи были написаны по дизайну Postgres: описание раннего дизайна в SIGMOD 1986 г. [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#SR86">SR86</a>] и промежуточное описание в CACM 1991 г. [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#SK91">SK91</a>]. Исследовательский проект Postgres постепенно «сошел на нет» в 1992 году с основанием Стоунбрейкером стартапа Illustra, в котором участвовали Стоунбрейкер, ведущий аспирант Вэй Хонг и позже ставший главным программистом Джефф Мередит (Jeff Meredith). В списке, приведенном ниже, возможности, упомянутые в статье 1986 года, отмечены звездочкой*, а возможности из статьи 1991 года, которых не было в статье 1986 года, — крестиком<sup>†</sup>. За другие задачи, перечисленные ниже, брались в системе и исследовательской литературе, но их нет ни в одной спецификации дизайна. Многие из этих тем рассматривались в Postgres задолго до того, как они были изучены или заново изобретены другими. Во многих случаях Postgres слишком опередил свое время, и интерес к темам вспыхнул позже, уже под современным углом зрения.<br><br></p><ol><li>Поддержка АТД в системе баз данных<br><ul><li>Сложные объекты (т. е. вложенные данные или данные не первой нормальной формы (non-first-normal form — NF2))*</li><li>Пользовательские абстрактные типы данных и функции*</li><li>Расширяемые методы доступа для новых типов данных*</li><li>Оптимизированная обработка запросов с дорогостоящими пользовательскими функциями</li></ul></li><li>Активные базы данных и системы правил (триггеры, предупреждения)*<br><ul><li>Правила, реализованные в виде перезаписи запроса<sup>†</sup></li><li>Правила, реализованные как триггеры уровня записи<sup>†</sup></li></ul></li><li>Хранение и восстановление на основе журнала<br><ul><li>Код восстановления с уменьшенной сложностью, рассматривающий журнал как данные*, использование энергонезависимой памяти для состояния фиксации<sup>†</sup></li><li>Хранилище без перезаписи и темпоральные запросы<sup>†</sup></li></ul></li><li>Поддержка новых технологий глубокого хранения данных, в особенности оптических дисков*</li><li>Поддержка мультипроцессоров и специализированных процессоров*</li><li>Поддержка различных языковых моделей<br><ul><li>Минимальные изменения реляционной модели и поддержка декларативных запросов*</li><li>Доступ к «быстрому пути» из внутренних API в обход языка запросов<sup>†</sup></li><li>Многоязычность<sup>†</sup></li></ul></li></ol><p><br>Мы кратко обсудим вклад Postgres по каждой из этих позиций в его связи с последующими работами в области вычислений.</p><h2>2.1. Поддержка АТД в системе баз данных</h2><p>Четко сформулированной целью Postgres была поддержка новых объектно-реляционных свойств: расширение технологии баз данных, чтобы обеспечить преимущества как реляционной обработки запросов, так и объектно-ориентированного программирования. Со временем объектно-реляционная концепция, впервые появившиеся в Postgres, стала стандартной функциональностью в большинстве современных систем баз данных.</p><h3>2.1.1. Сложные объекты</h3><p>Довольно часто данные представляются в виде вложенных сущностей или «объектов». Классическим примером является заказ на покупку, который имеет вложенный набор продуктов, их количеств и цен. Религия реляционного моделирования диктовала, что такие данные должны быть реструктурированы и сохранены в формате без вложенности, используя несколько плоских таблиц объектов (заказы, продукты) с соединяющими их плоскими таблицами отношений (продукт_в_заказе). Типичная причина такого уплощения заключается в том, что оно уменьшает дублирование данных (т. к. продукт избыточно описывается во многих заказах на покупку), что, в свою очередь, позволяет избежать сложности или ошибок при обновлении всех избыточных копий. Но в некоторых случаях вы хотите сохранить вложенное представление, потому что это естественно для приложения (например, механизм компоновки схемы в САПР), а обновления редки. Этот спор о моделировании данных по крайней мере так же стар, как и реляционная модель.<br><br>Ключевым подходом Postgres было «усидеть на двух стульях» с точки зрения моделирования данных: Postgres сохранил таблицы как «самый внешний» тип данных, но позволил столбцам иметь «сложные» типы, включая вложенные кортежи или таблицы. Одна из его малораспространенных реализаций, впервые исследованная в прототипе ADT-Ingres, заключалась в том, чтобы разрешить задавать столбец табличного типа декларативно, как определение запроса: «Quel как тип данных» [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#SAHR84">SAHR84</a>] <em>(Quel — язык запросов Ingres. — Прим. пер.)</em>.<br><br>«Постреляционная» тема поддержки как декларативных запросов, так и вложенных данных вновь возникала на протяжении многих лет, часто порождаемая спорами о том, что лучше. Во времена Postgres в 1980-х и 1990-х годах некоторые группы, занимающиеся объектно-ориентированными базами данных, подхватили эту идею и развили ее в стандартный язык OQL, который затем перестал использоваться.<br><br>На рубеже тысячелетий декларативные запросы к вложенным объектам стали навязчивой идеей исследований для сегмента сообщества разработчиков баз данных в виде баз данных XML. Получившийся в результате язык XQuery (во главе с Доном Чемберлином (Don Chamberlin) — персоной SQL) обязан поддержке сложных объектов языку Postquel из Postgres. XQuery получил широкое распространение и использование в промышленности, но никогда не был популярен у пользователей. Сегодня эти концепции вновь рассматриваются в проектах языков запросов для модели данных JSON, популярной в браузерных приложениях. Как и OQL, в группах, которые первоначально отвергали декларативные запросы в пользу программирования, ориентированного на разработчиков (движение «NoSQL»), эти языки часто возникают как запоздалое дополнение исключительно из желания добавить запросы обратно в системы. В то же время по мере роста Postgres с годами (и перехода от языка запросов Postquel к версиям SQL, которые отвечают многим из рассматриваемых целей), он включил поддержку вложенных данных, таких как XML и JSON, в СУБД общего назначения, не требуя какого-либо значительного перепроектирования. Споры протекают с переменным успехом, а подход Postgres к расширению реляционной структуры с помощью расширений для вложенных данных не раз показал себя естественным конечным состоянием для всех сторон после того, как аргументы утихают.</p><h3>2.1.2. Пользовательские абстрактные типы данных и функции</h3><p>В дополнение к предложению вложенных типов Postgres выдвинул идею ввести непрозрачные, расширяемые АТД, которые хранятся в базе данных, но не интерпретируются ядром. В принципе, это всегда было частью реляционной модели Кодда: целые числа и строки были традиционными, но на самом деле реляционная модель охватывает любые атомарные типы данных с предикатами. Задача состояла в том, чтобы обеспечить такую математическую гибкость и в программном обеспечении. Чтобы использовать запросы, которые интерпретируют эти объекты и манипулируют ими, прикладной программист должен иметь возможность регистрировать в системе определяемые пользователем функции (user-defined functions — UDF) для этих типов и вызывать эти функции в запросах. Также желательно, чтобы определяемые пользователем агрегатные (user-defined aggregate — UDA) функции суммировали коллекции этих объектов в запросах. Система баз данных Postgres была новаторской, всесторонне поддерживая эти возможности.<br><br>Зачем помещать такую функциональность в СУБД, а не в высокоуровневые приложения? Типичным ответом на этот вопрос было значительное преимущество в производительности кода, помещенного к данным, перед «вытягиванием» данных к коду. Postgres показал, что это вполне естественно в рамках реляционной среды: потребовались лишь небольшие изменения в каталоге реляционных метаданных и были созданы механизмы вызова стороннего кода, но синтаксис запросов, семантика и системная архитектура работали просто и элегантно.<br><br>Postgres немного опередил свое время в исследовании этой функциональности. В частности, в то время сообщество исследователей баз данных не особенно беспокоилось о последствиях для безопасности при загрузке небезопасного кода на сервер. Это стало восприниматься как проблема, когда технологию заметили в индустрии. Стоунбрейкер вывел на рынок Postgres в своем стартапе Illustra, который был приобретен Informix в значительной степени за его способность поддерживать пакеты расширений DataBlade, в том числе UDF. Informix с технологией, основанной на Postgres, и сильным предложением параллельных баз данных стала значительной угрозой Oracle. Oracle инвестировала значительные средства в негативный маркетинг рисков, связанных со способностью Informix запускать «незащищенный» пользовательский C-код. Некоторые относят гибель Informix к этой кампании, хотя финансовые махинации Informix (и последующее федеральное обвинение его тогдашнего генерального директора), безусловно, представляли собой более серьезные проблемы. Теперь, десятилетия спустя, все основные поставщики баз данных поддерживают выполнение пользовательских функций на одном или более языках, используя новые технологии защиты от сбоев сервера или повреждения данных.<br><br>Между тем, технологические стеки больших данных 2000-х годов, включая феномен MapReduce, который «много крови попортил» Стоунбрейкеру и ДеВитту (David DeWitt) [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#DS08">DS08</a>], являются повторной реализацией идеи Postgres — пользовательского кода, размещенного в рамках запроса. Представляется, что MapReduce во многом сочетает идеи разработки программного обеспечения от Postgres с идеями параллелизма от таких систем, как Gamma и Teradata, с некоторыми незначительными инновациями вокруг перезапуска в процессе выполнения запроса для рабочих нагрузок с экстремальной масштабируемостью. Стартапы на базе Postgres, Greenplum и Aster, примерно в 2007 году показали, что распараллеливание Postgres может привести к чему-то гораздо более функциональному и практичному, чем MapReduce, для большинства клиентов, но в 2008 году рынок все еще не был готов к этой технологии. К настоящему времени, в 2018 году, почти каждый стек больших данных в основном обслуживает рабочую нагрузку параллельного SQL с UDF, что очень похоже на дизайн, который Стоунбрейкер с командой впервые использовали в Postgres.</p><h3>2.1.3. Расширяемые методы доступа для новых типов данных</h3><p>Реляционные базы данных развивались примерно в то же время, что и B-деревья, в начале 1970-х годов, и B-деревья помогли дать импульс мечте Кодда о «независимости от физического хранения данных»: индексирование B-деревьями обеспечивает уровень косвенности, который адаптивно реорганизует физическое хранилище, не требуя изменения приложений. Основным ограничением B-деревьев и связанных с ними структур было то, что они поддерживают только поиск по равенству и запросы одномерного диапазона. А что делать, если у вас есть запросы 2-мерного диапазона, типичные для картографии и приложений САПР? Эта проблема была известна во время Postgres, и R-дерево [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#Gut84">Gut84</a>], разработанное Антонином Гуттманом в группе Стоунбрейкера, было одним из самых успешных новых индексов, разработанных для решения этой проблемы на практике. Тем не менее, изобретение индексной структуры не решает для комплексных систем задачу поддержки в СУБД многомерных диапазонов. Возникает много вопросов. Можете ли вы легко добавить метод доступа, такой как R-деревья, в свою СУБД? Можете ли вы научить оптимизатор понимать, что указанный метод доступа будет полезен для определенных запросов? Вы можете добиться корректности восстановления и одновременного доступа? Это был очень смелый пункт программы действий Postgres: проблема архитектуры программного обеспечения, затрагивающая большую часть ядра базы данных, от оптимизатора до уровня хранения, а также системы журналирования и восстановления. R-деревья в Postgres стали мощной движущей силой и основным примером элегантной расширяемости уровня метода доступа и его интеграции в оптимизатор запросов. Postgres показал, способом непрозрачных АТД, как зарегистрировать абстрактно описанный метод доступа (в данном случае R-дерево), и как оптимизатор запросов может распознать абстрактный предикат выборки (в данном случае выбор диапазона) и сопоставить его с этим абстрактно описанным методом доступа. Вопросам управления одновременным доступом было уделено меньше внимания в первоначальной работе: отсутствие одномерного упорядочения ключей сделало в данном случае блокировку, применяемую в B-деревьях, неприменимой.<br><br><em>Многообещающие возможности расширяемых методов доступа Postgres вдохновили один из моих первых исследовательских проектов в конце аспирантуры: обобщенные деревья поиска (Generalized Search Trees—GiST) [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#HNP95">HNP95</a>] и последующую концепцию теории индексируемости [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#HKM02">HKM<sup>+</sup>02</a>]. Я реализовал GiST в Postgres в течение семестра после получения докторской степени, что сделало добавление новой логики индексирования в Postgres еще проще. В диссертации Марселя Корнакера из Беркли (Marcel Kornacker) решены сложные задачи восстановления и одновременного доступа, поставленные расширяемым «шаблонным» типом индекса GiST [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#KMH97">KMH97</a>].</em><br><br>Сегодня PostgreSQL выгодно сочетает оригинальную программную архитектуру расширяемых методов доступа (она имеет индексы B-tree, GiST, SP-GiST и Gin) с расширяемостью и интенсивным конкурентным доступом интерфейса обобщенного дерева поиска (GiST). Индексы GiST поддерживают популярную гео-информационную систему PostGIS на базе PostgreSQL. Индексы Gin обеспечивают внутреннюю поддержку индексирования текста в PostgreSQL.</p><h3>2.1.4. Оптимизатор обработки запросов с дорогостоящими UDF</h3><p>В традиционной оптимизации запросов задача состояла в том, чтобы свести к минимуму объем потока кортежей (и, следовательно, операций ввода-вывода), создаваемых при обработке запроса. Это означало, что операторы, которые фильтруют кортежи (выборка), хороши в начале плана запроса, в то время как операторы, которые могут генерировать новые кортежи (соединение), должны быть выполнены позже. В результате оптимизаторы запросов будут «выталкивать» операторы выборки ниже соединений и упорядочивать их произвольно, сосредотачиваясь вместо этого на умной оптимизации соединений и обращений к диску. UDF изменили подход: если у вас в операторах выборки дорогостоящие UDF, порядок выполнения UDF может иметь решающее значение для оптимизации производительности. Более того, если UDF в операторе выборки действительно занимает много времени, возможно, выборку следует выполнять после соединений (т. е. выполнить «подтягивание» выборки вверх — selection «pullup»). Учет этих факторов усложнил пространство поиска для оптимизатора. Я взял эту проблему как первую сложную задачу в аспирантуре, и кончилось тем, что она стала предметом моей магистерской работы со Стоунбрейкером в Беркли и моей кандидатской в Висконсине под руководством Джеффа Нотона (Jeff Naughton), но при постоянной помощи советами от Стоунбрейкера. СУБД Postgres была первой, которая сохраняла стоимость и избирательность пользовательских функций в каталоге базы данных. Мы подошли к задаче оптимизации, придумав оптимальный порядок операций выборки, а затем оптимальное чередование операций выборки вдоль ветвей каждого дерева соединений, рассматриваемого при поиске плана. Это позволило оптимизатору поддерживать архитектуру классического динамического программирования System R с небольшой дополнительной стоимостью сортировки для правильного упорядочения дорогостоящих операторов выборки.<br><br><em>Когда я поступил в аспирантуру, это была одна из трех тем, которые Стоунбрейкер написал на доске в своем кабинете как варианты для выбора темы моей диссертации. Кажется, второй темой было индексирование функций, а третьей я не помню.</em><br><br>Оптимизация дорогостоящих функций была отключена в деревьях исходного кода PostgreSQL на ранней стадии в значительной степени потому, что в то время не было убедительных вариантов использования дорогостоящих пользовательских функций. Примеры, которые мы использовали, вращались вокруг обработки изображений и, наконец, в 2018 году они становятся востребованными задачами обработки данных. Конечно, сегодня, в эпоху больших данных и рабочих нагрузок машинного обучения, дорогостоящие функции стали довольно распространенным явлением, и я ожидаю, что эта проблема вернется на передний план. В очередной раз отметим, что Postgres сильно опередил свое время.<br><br><em>По иронии судьбы, код, написанный мною в аспирантуре, был полностью удален из дерева исходных текстов PostgreSQL молодым программистом по имени Нил Конвей (Neil Conway), который несколько лет спустя начал делать кандидатскую диссертацию под моим руководством в Калифорнийском университете в Беркли и теперь является одним из «кандидатских внуков» Стоунбрейкера.</em></p><h2>2.2. Активные базы данных и системы правил</h2><p>Проект Postgres начался на исходе интереса сообщества искусственного интеллекта к программированию на основе правил как способу представления знаний в экспертных системах. Такой ход мысли не привел к успеху: многие считают, что это вызвало широко обсуждаемую «зиму искусственного интеллекта», которая продолжалась на протяжении 1990-х годов.<br><br>Однако программирование на основе правил сохранялось в сообществе разработчиков баз данных в двух формах. Первая — теоретическая работа вокруг декларативного логического программирования с использованием Datalog. Она была «костью в горле» для Стоунбрейкера: он, казалось, действительно ненавидел эту тему и хлестко критиковал ее в нескольких докладах сообщества на протяжении многих лет.<br><br><em>Datalog выжил как математическая основа для декларативных языков и со временем нашел применение в различных областях информатики, включающих программно-конфигурируемые сети и компиляторы. Datalog — это декларативное построение запросов «на стероидах» как вполне выразительная модель программирования. В конце концов я был вовлечен в это, как в естественный вариант дизайна, и следовал этому в различных прикладных настройках за пределами традиционных систем баз данных.</em><br><br>Второй круг вопросов, связанных с правилами баз данных, был практической работой над тем, что в конечном итоге было названо активными базами данных и триггерами баз данных, которые развились в стандартную функциональность реляционных СУБД. Стоунбрейкер в свойственной ему манере проголосовал ногами за работу над более практическим вариантом.<br><br>Работа Стоунбрейкера над правилами баз данных началась с кандидатской работы Эрика Хэнсона (Eric Hanson), которая первоначально делалась для Ingres, но быстро переместилась в новый проект Postgres. Она была расширена в кандидатской работе Спироса Потамианоса (Spyros Potamianos) над PRS2: Postgres Rules System 2. Темой в обеих реализациях была возможность реализовать правила двумя различными способами. Один из них — трактовать правила как перезапись запросов. Это напоминает работу над перезаписью представлений, что впервые сделал Стоунбрейкер в Ingres. В этом сценарии логика правила «при условии выполнить действие» преобразуется в «при запросе перезаписать его и выполнить вместо исходного». Например, запрос типа «добавить новую строку к списку наград Майка» может быть переписан как «повысить зарплату Майка на 10%». Другой способ состоял в том, чтобы реализовать более естественное «при условии выполнить действие», проверяя условия на уровне строк с помощью блокировок внутри базы данных. При обнаружении таких блокировок результатом было не ожидание (как в традиционном управлении одновременным доступом), а выполнение соответствующего действия.<br><br><em>Код для правил уровня строк в PRS2 был, как печально известно, сложным. Небольшим поиском в архивах Postgres в Беркли был обнаружен следующий комментарий (вероятно, Спироса Потамианоса) к исходному коду Postgres версии 3.1 примерно 1991 года (дается в переводе):</em><br><br></p><pre>* О П И С А Н И Е:* Сделай глубоооокий вдох и прочти. Если ты не можешь не влезать в нижеследующий* код (т. е. если босс не вынудил тебя добровольно делать это* "грязное" дело) избегай этого любой ценой. Попробуй делать что-то менее опасное* для твоего (психического) здоровья. Иди домой и посмотри фильмы ужасов по телевизору.* Почитай немного Лавкрафта.  Пойди служить в армию.  Иди и проведи несколько ночей* в народном парке. Соверши самоубийство...* Что, продолжаешь читать, неужели? Хорошо, тогда ты заслуживаешь того, что получил.* Добро пожаловать в мрачный лабиринт системы правил уровня кортежей, мой* бедный коллега...</pre><p><br>В итоге для реализации правил в Postgres ни метод перезаписи запросов, ни метод блокировки на уровне строк не были объявлены «победителями» — оба были сохранены в выпущенной системе. В конце концов код всех правил был забракован и переписан в PostgreSQL, но текущий исходный код по-прежнему сохраняет оба понятия триггеров на уровне операторов и на уровне строк.<br><br>Системы правил Postgres в свое время имели очень большое влияние и шли «ноздря в ноздрю» с исследованиями по проектам IBM Starburst и MCC HiPAC. Сегодня триггеры являются частью стандарта SQL и реализованы в движках многих основных баз данных. Однако они используются с некоторой осторожностью. Одна из проблем заключается в том, что наработки, о которых говорилось, так и не преодолели негативных моментов, которые привели к «зиме искусственного интеллекта»: взаимодействия в нагромождении правил могут стать неприемлемо запутанными, даже когда набор правил растет незначительно. Кроме того, на практике по-прежнему выполнение триггеров обычно занимает относительно много времени, поэтому внедряемые базы данных, которые должны работать быстро, как правило, избегают использования триггеров. Однако была некоторая кустарщина в смежных областях, таких как поддержка материализованных представлений, обработка сложных событий и потоковые запросы, каждая из которых в некотором роде является расширениями идей, исследованных в системах правил Postgres.</p><h2>2.3. Xранение и восстановление на основе журнала</h2><p>Стоунбрейкер описал свой дизайн системы хранения Postgres таким образом:</p><blockquote>Обдумывая систему хранения Postgres, мы руководствовались миссионерским рвением сделать что-то необычное. Все современные коммерческие системы используют менеджер хранилища с журналом упреждающей записи (write-ahead log — WAL), и мы чувствовали, что эта технология хорошо понятна. Более того, оригинальный прототип Ingres 1970-х годов использовал аналогичный менеджер хранилища, и у нас не было желания делать другую реализацию. [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#SK91">SK91</a>]</blockquote><p>Хотя это выглядит, как чистая интеллектуальная неугомонность, были и технологические основания для этой работы. На протяжении многих лет Стоунбрейкер неоднократно выражал неприязнь к сложным схемам ведения журнала упреждающей записи, впервые разработанным в IBM и Tandem для восстановления баз данных. Одно из его основных возражений основано на интуиции разработчика программного обеспечения: никто не должен полагаться на что-то столь сложное, особенно для функциональности, которая будет использоваться только в редких, критических сценариях после сбоя.<br><br>Xранилище Postgres объединило понятия основного хранилища и журналирования исторической информации в единое простое дисковое представление. В своей основе идея заключалась в том, чтобы хранить каждую запись в базе данных в связанном списке версий, помеченных идентификаторами транзакций, — в некотором смысле это «журнал как данные» или «данные как журнал» в зависимости от вашей точки зрения. Единственные дополнительные метаданные, которые необходимы, — это список идентификаторов завершенных транзакций и времени их фиксации. Этот подход значительно упрощает восстановление, так как нет «перевода» из журнального представления обратно в основное представление. Он также делает возможными темпоральные запросы: вы можете выполнять запросы по состоянию на некоторый момент времени и получать доступ к версиям данных, которые были зафиксированы в это время. Первоначальный дизайн системы хранения Postgres, который выглядит так, как будто Стоунбрейкер описал его в одном творческом сеансе мозгового штурма, рассматривал ряд проблем эффективности и оптимизации базовой схемы наряду с грубым анализом того, как может повести себя производительность [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#Sto87">Sto87</a>]. Итоговая реализация в Postgres была несколько проще.<br><br>Мнение Стоунбрейкера о «радикальной простоте» транзакционного хранилища было глубоко противоположно принятым в сообществе в то время, когда поставщики баз данных выделяли себя, инвестируя значительные средства в алгоритмы высокопроизводительной обработки транзакций. В то время победители сравнительных тестов достигали высокой производительности и возможности восстановления благодаря хорошо оптимизированным системам ведения журнала упреждающей записи. После того, как они получили хорошо работающие журналы упреждающей записи, поставщики также начали нововведения следующего этапа, такие как транзакционная репликация на основе доставки журнала, что было трудно осуществить в Postgres. В итоге система хранения Postgres так и не отличилась в производительности. Версионность и темпоральные запросы были позже удалены из PostgreSQL и заменены использованием журнала упреждающей записи.<br><br><em>К сожалению, PostgreSQL все еще не особенно быстро обрабатывает транзакции: использование в нем журнала упреждающей записи несколько половинчато. Как ни странно, команда PostgreSQL сохранила много служебной информации, хранимой вместе с кортежами в Postgres, для обеспечения многоверсионности, что никогда не было целью проекта Postgres в Беркли. Результатом является система хранения, которая может эмулировать изоляцию снимков (snapshot isolation) Oracle с изрядным объемом дополнительных накладных расходов ввода-вывода, но которая не следует первоначальной мысли Стоунбрейкера о темпоральных запросах или простом восстановлении.</em><br><br><em>Майк Олсон (Mike Olson) отмечает, что его первоначальное намерение состояло в том, чтобы заменить реализацию B-дерева Postgres своей собственной реализацией B-дерева из проекта Berkeley DB, который разрабатывался в Беркли в эпоху Postgres. Но Олсон так и не нашел на это времени. Когда годы спустя Berkeley DB получила поддержку транзакций в Sleepycat Corp., Олсон попытался убедить (тогдашнее) сообщество PostgreSQL использовать его для восстановления вместо хранилища «без перезаписи». Они отказались: в проекте был программист, который отчаянно хотел построить систему с многоверсионностью (MVCC), и поскольку он был готов выполнить работу, он выиграл спор.</em><br><br><em>Медленно работающее хранилище PostgreSQL не является внутренне присущим системе. В Greenplum ветка PostgreSQL в качестве интересной альтернативы интегрировала высокопроизводительное сжатое хранилище. Оно было разработано Мэттом МакКлином (Matt McCline)—ветераном команды Джима Грея (Jim Gray) в компании Tandem. Оно также не поддерживало темпоральных запросов.</em><br><br>Но возможность темпоральных запросов была интересной и оставалась уникальной. Более того, кредо Стоунбрейкера в отношении разработки простого программного обеспечения для восстановления данных сегодня имеет отголоски как в контексте систем NoSQL (которые выбирают репликацию, а не WAL), так и в базах данных основной памяти (MMDB — main memory databases, которые часто используют многоверсионность и сжатые журналы фиксации). Идея версионных реляционных баз данных и темпоральных запросов сегодня все еще отнесена к эзотерике, появляясь в случайных исследовательских прототипах и небольших проектах с открытым исходным кодом. Это идея, которая созрела для возвращения в нашу эпоху дешевого хранения и непрерывных потоков данных.</p><h2>2.4. Запросы к данным на носителях с новыми технологиями глубокого хранения</h2><p>В середине проекта Postgres Стоунбрейкер подписался в качестве одного из руководителей на большой грант по научному направлению «цифровая земля» под названием Project Sequoia. Часть грантового предложения заключалась в обработке беспрецедентных объемов цифровых спутниковых изображений, требующих до 100 терабайт памяти, т. е. намного большего объема данных, чем в то время было бы разумно хранить на магнитных дисках. В основе предлагаемого решения было исследовать идею создания СУБД (а именно Postgres), облегчающей доступ к полуавтономному «третичному» хранилищу, предоставляемому роботизированными накопителями с автоматической сменой дисков для управления библиотеками оптических дисков или лент.<br><br>Из этого вытекало несколько разных исследований. Одним из них была файловая система Inversion — попытка предоставить абстракцию файловой системы UNIX над реляционной СУБД. В обзорной статье для Sequoia Стоунбрейкер описал это в своем обычном стиле свысока как «простое упражнение» [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#Sto95">Sto95</a>]. На самом деле Майк Олсон, студент Стоунбрейкера (и последующий основатель компании Cloudera), был занят этим в течение нескольких лет, да и конечный результат не был вполне однозначным [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#Ols93">Ols93</a>] и не выжил на практике.<br><br><em>На несколько лет позже Inversion Билл Гейтс «бился с теми же ветряными мельницами» в WinFS — попытке воссоздать наиболее широко используемую в мире файловую систему над серверной частью реляционной базы данных. WinFS поставлялась в разработческих версиях Windows, но так и не вышла на рынок. Гейтс позже назвал это своим самым большим в Microsoft разочарованием.</em><br><br>Другим основным направлением исследований на этом фронте было включение третичного хранилища в стек более типичных реляционных баз данных, что было предметом кандидатской диссертации Суниты Сараваги (Sunita Sarawagi). Основной темой было изменение масштаба, в котором вы мыслите управление пространством (т. е. данными в хранилище и иерархии памяти) и временем (координация планирования запросов и кеша для минимизации нежелательных операций ввода-вывода). Одной из ключевых проблем в этой работе было хранение больших многомерных массивов в третичном хранилище и извлечение их, что перекликается с работами в области многомерного индексирования. Основные идеи включали разбиение массива на порции и хранение вместе порций, которые выбираются вместе, а также репликацию порций, чтобы указанная порция данных могла иметь нескольких физических «соседей». Вторая проблема — подумать о том, как диск становится кешем для третичного хранилища. Наконец, оптимизация запросов и планирование должны были учитывать длительное время загрузки данных из третичного хранилища и важность попаданий (hits) кеша диска. Это влияет как на план, выбираемый оптимизатором запросов, так и на время, на которое этот план намечен к выполнению.<br><br>Роботы на лентах и оптических дисках в настоящее время широко не используются. Но проблемы третичного хранилища очень распространены в облаке, которое в 2018 году имеет глубокую иерархию хранения: от присоединенных твердотельных дисков к услугам надежного дископодобного хранилища (например, AWS EBS), к архивному хранилищу (например, в AWS S3), к глубокому хранилищу (например, AWS Glacier). Сегодня эти уровни хранения по-прежнему относительно обособлены, и рассуждения о сквозном хранилище, охватывающем эти уровни, практически не поддерживаются базой данных. Я не удивлюсь, если вопросы, исследованные на этом фронте в Postgres, будут пересмотрены в ближайшее время.</p><h2>2.5. Поддержка мультипроцессоров: XPRS</h2><p>Стоунбрейкер никогда не создавал большую параллельную систему баз данных, но он руководил многими стимулирующими дискуссиями в этой области. Его статья «Case for Shared Nothing» (Случай для систем без разделяемых ресурсов) [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#Sto86">Sto86</a>] задокументировал крупномодульные архитектурные решения в этой области. Он популяризировал терминологию, используемую в отрасли, и озадачил поддержкой архитектур без совместно используемых ресурсов, таких как Gamma и Teradata, которые были заново открыты в 2000-х годах сообществом работающих над большими данными.<br><br>По иронии судьбы, самым существенным вкладом Стоунбрейкера в область параллельных баз данных была архитектура «общей памяти» под названием XPRS, что означало «eXtended Postgres on RAID and Sprite». В начале 1990-х годов XPRS была «лигой справедливости» систем Беркли: она объединяет в сокращенном виде систему Postgres Стоунбрейкера, распределенную ОС Sprite Джона Остерхаута (John Ousterhout) и архитектуру RAID-хранилищ Дейва Паттерсона (Dave Patterson) и Рэнди Каца (Randy Katz). Как и для многих межфакультетских работ, выполнение проекта XPRS фактически определялось аспирантами, которые работали над ним. Оказалось, что основной вклад внес Вэй Хонг, который написал свою кандидатскую диссертацию по оптимизации параллельных запросов в XPRS. Таким образом, основным вкладом XPRS в литературу и индустрию была оптимизация параллельных запросов без существенного рассмотрения проблем, связанных с RAID или Sprite.<br><br><em>Из этих трех проектов огромное влияние на дальнейшее оказали Postgres и RAID. Sprite лучше всего помнят по кандидатской диссертации Менделя Розенблюма (Mendel Rosenblum) о файловых системах с журнальной структурой (Log Structured File Systems — LFS), которая не имела ничего примечательно общего с распределенными операционными системами. Все три проекта содержали новые идеи для дискового хранения, помимо видоизменения отдельных копий по месту. LFS и менеджер хранилища Postgres довольно похожи новым отношением к журналу как к основному хранилищу и необходимостью дорогостоящей фоновой реорганизации. Однажды я осторожно прощупывал Стоунбрейкера на предмет соперничества LFS и Postgres или академических «жареных фактов» об их взаимоотношениях, но я так и не узнал от него ничего интересного. Возможно, в то время в Беркли кто-то «мутил воду».</em><br><br>В принципе, параллелизм «взрывает» пространство планов оптимизатора запросов, умножая традиционные варианты выбора, сделанные во время оптимизации запросов (доступ к данным, алгоритмы соединений, порядок соединений), на все возможные способы распараллеливания каждого варианта выбора. Основная идея названного Стоунбрейкером «оптимизатора Вэя Хонга» заключалась в том, чтобы разбить проблему на две: запустить традиционный оптимизатор запросов в духе System R для одного узла, а затем «распараллелить» получившийся план, запланировав степень параллелизма и размещение каждого оператора, исходя из представления данных и конфигурации системы. Этот подход эвристичен, но в нем параллелизм наращивает стоимость традиционной оптимизации запросов аддитивно, а не мультипликативно.<br><br>Хотя оптимизатор Вэя Хонга был разработан в контексте Postgres, он стал стандартным подходом для многих оптимизаторов параллельных запросов в отрасли.</p><h2>2.6. Поддержка различных языковых моделей</h2><p>Среди интересов Стоунбрейкера, неоднократно возобновляющихся со времен Ingres, был интерфейс прикладного программирования (API) системы баз данных. В свои лекции из серии Database Systems (Системы баз данных) он часто включал язык GEM Карло Заниоло (Carlo Zaniolo) как тему, которую важно понять поборникам систем баз данных. Этот интерес к языку, несомненно, привел его к партнерству с Ларри Роу в Postgres, что, в свою очередь, глубоко повлияло на дизайн модели данных Postgres и ее объектно-реляционный подход. Их работа была сосредоточена в основном на приложениях для работы с большим объемом данных из коммерческой сферы, включающих как обработку деловой информации, так и новые приложения, такие как САПР/АСУП и ГИС.<br><br>Одной из проблем, которая была навязана в то время Стоунбрейкеру, была идея «спрятать» границы между конструкциями языка программирования и хранилищем базы данных. Различные конкурирующие исследовательские проекты и компании, исследующие объектно-ориентированные базы данных (Object-Oriented Databases — OODB), были нацелены на так называемую «потерю соответствия» между императивными объектно-ориентированными языками программирования, такими как Smalltalk, C++ и Java, и декларативной реляционной моделью. Идея OODB состояла в том, чтобы сделать объекты языка программирования при желании помечаемыми как «постоянные» и автоматически обрабатываемыми встроенной СУБД. Postgres поддерживал хранение вложенных объектов и абстрактных типов данных, но его интерфейс, основанный на декларативных запросах в реляционном стиле, предполагал неестественные для программиста обращения к базе данных (требовал от него использования декларативных запросов), которые к тому же были дорогостоящими (требовали синтаксического разбора и оптимизации). Чтобы конкурировать с поставщиками OODB, Postgres предоставил так называемый интерфейс «быстрого пути» (Fast Path): по сути API C/C++ к внутреннему устройству хранения базы данных. Это позволило Postgres иметь среднюю производительность по академическим тестам OODB, но так никогда и не решило задачи позволить программистам на разных языках избежать проблемы потери соответствия. Вместо этого Стоунбрейкер навесил на модель Postgres ярлык «объектно-реляционной» и просто обошел стороной применение объектно-ориентированных баз как невыгодный рынок (zero-billion dollar market). Сегодня практически все коммерческие системы реляционных баз данных являются «объектно-реляционными» системами баз данных.<br><br>Это оказалось разумным решением. Сегодня ни один из продуктов OODB не существует в своей задуманной форме, и идея «постоянных объектов» в языках программирования была большей частью отброшена. В отличие от этого, широко распространено использование слоев объектно-реляционного отображения (object-relational mapping — ORM, подпитываемое ранними работами, такими как Java Hibernate и Ruby on Rails), что позволяет относительно гладко «подгонять» декларативные базы данных почти под любой императивный объектно-ориентированный язык программирования в качестве библиотек. Этот подход на уровне приложения отличается как от OODB, так и от объектно-реляционных баз данных по Стоунбрейкеру. Кроме того, легковесные хранилища «ключ-значение» также успешно используются как в бестранзакционной, так и в транзакционной форме. Их первооткрывателем была аспирантка Стоунбрейкера Марго Зельцер (Margo Seltzer), которая работала над базой данных Berkeley DB в рамках своей кандидатской диссертации в то же время, что и группа Postgres, что предвосхитило рост таких распределенных NoSQL-хранилищ «ключ-значение», как Dynamo, MongoDB и Cassandra.</p><h1>3. Влияние на программное обеспечение</h1><h2>3.1. Открытый исходный код</h2><p>Postgres всегда был проектом с открытым исходным кодом с равномерными релизами, но вначале длительное время он был нацелен на использование в исследованиях, а не в производстве.<br><br>Поскольку исследовательский проект Postgres сворачивался, два студента Стоунбрейкера Эндрю Ю (Andrew Yu) и Джолли Чен (Jolly Chen) модифицировали синтаксический анализатор системы, чтобы заменить оригинальный язык Postquel расширяемым вариантом SQL. Первым релизом Postgres, поддерживающим SQL, был Postgres95, а следующий был назван PostgreSQL.<br><br>Группа разработчиков открытого исходного кода заинтересовалась PostgreSQL и «приняла» его даже тогда, как интересы остальной части команды Беркли изменились. Группа основных разработчиков PostgreSQL со временем остается относительно стабильной, и проект с открытым исходным кодом стал высокоразвитым. Вначале усилия были сосредоточены на стабильности кода и функциональности, видимой пользователю, но со временем сообщество разработчиков программного обеспечения с открытым исходным кодом значительно изменило и усовершенствовало ядро системы, от оптимизатора до методов доступа и основной системы транзакций и хранения. С середины 1990-х годов очень небольшая часть внутренних составляющих PostgreSQL исходила от академической группы в Беркли. Последним ее вкладом, возможно, была моя реализация GiST во второй половине 1990-х годов, но даже она была существенно переписана и очищена добровольцами из сообщества открытого исходного кода (в данном случае из России). Часть сообщества открытого исходного кода, что работает над PostgreSQL, заслуживает величайшей похвалы за осуществление упорядоченного процесса, который на протяжении десятилетий служил созданию в высшей степени эффективного и долгосрочного проекта.<br><br>Хотя многое изменилось за 25 лет, базовая архитектура PostgreSQL остается очень похожей на университетские релизы Postgres начала 1990-х годов, и разработчикам, знакомым с текущим исходным кодом PostgreSQL, будет нетрудно читать исходный код Postgres 3.1 (1991 г.). Все, от структуры каталогов исходного кода до структур процессов и структур данных, остается удивительно похожим. Код из команды Postgres в Беркли имел отличный костяк.<br><br>Сегодня PostgreSQL, без сомнения, является самой высокопроизводительной СУБД с открытым исходным кодом, причем она поддерживает функциональность, которая часто отсутствуют в коммерческих продуктах. Она также является (по словам одного влиятельного рейтингового сайта) наиболее популярной в мире широко используемой независимой СУБД с открытым кодом, и ее влияние продолжает расти: в 2017 и 2018 годах она была базой данных с самой быстро растущей популярностью в мире [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#DE19c">DE19c</a>]. PostgreSQL используется в самых разных отраслях промышленности и задачах, что неудивительно, учитывая ее нацеленность на широкие возможности.<br><br><em>По данным DB-Engines, PostgreSQL сегодня является четвертой по популярности СУБД в мире, после Oracle, MySQL и MS SQL Server, причем все три предлагаются конкретными компаниями (MySQL был приобретен Oracle много лет назад) [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#DE19a">DE19a</a>]. Правила ранжирования обсуждаются в описании методологии ранжирования DB-Engines [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#DE19b">DE19b</a>].</em><br><br>Heroku — облачный провайдер SaaS, который теперь является частью Salesforce. Postgres был внедрен в Heroku в 2010 году в качестве базы данных по умолчанию для своей платформы. Heroku выбрал Postgres за надежность в работе. С поддержкой со стороны Heroku более крупные платформы разработки приложений, такие как Ruby on Rails и Python for Django, стали рекомендовать Postgres в качестве базы данных по умолчанию.<br><br>Сегодня PostgreSQL поддерживает инфраструктуру расширений, которая позволяет легко добавлять дополнительные возможности в систему через пользовательские функции и связанные с ним модификации. Теперь есть экосистема расширений PostgreSQL, сродни концепции llustra пакетов расширений DataBlade, но с открытым исходным кодом. Наиболее интересные расширения включают, например, библиотеку Apache MADlib для машинного обучения в интерфейсе SQL и библиотеку Citus для параллельного выполнения запросов.<br><br>Одним из наиболее интересных приложений с открытым исходным кодом, построенных над Postgres, является географическая информационная система PostGIS, использующая многие возможности Postgres, которые первоначально вдохновили Стоунбрейкера начать проект.</p><h2>3.2. Коммерческое внедрение</h2><p>PostgreSQL уже давно является привлекательной отправной точкой для создания коммерческих систем баз данных, учитывая его использование по «всепозволяющей» лицензии на программное обеспечение с открытым исходным кодом, надежный код, гибкость и широкую функциональности. Суммируя стоимости приобретения, перечисленные ниже, видим, что от Postgres получилось более 2,6 млрд. долларов стоимости приобретения.<br><br><em>Обратите внимание, что это мера в долларах реальных финансовых операций и гораздо более существенная, чем значения, которые часто используются в сфере высоких технологий. Цифры в миллиардах часто используются для описания оценочной стоимости пакетов акций, но часто завышаются в 10 раз или более по сравнению с нынешней стоимостью в надежде на ее будущее значение. Доллары сделки приобретения компании измеряют ее фактическую рыночную стоимость на момент приобретения. Будет справедливым сказать, что Postgres создала более 2,6 миллиардов долларов реальной коммерческой стоимости.</em><br><br>Многие коммерческие усилия, связанные с PostgreSQL, были направлены на то, что, вероятно, является ее основным ограничением: возможность масштабирования до параллельной архитектуры без разделения ресурсов.<br><br><em>Распараллеливание PostgreSQL требует изрядной работы, но в высшей степени выполнимо небольшой опытной командой. Сегодня, отраслевые ветки открытого исходного кода PostgreSQL, такие как Greenplum и CitusDB, предоставляют такую возможность. Жаль, что PostgreSQL не был правильно распараллелен в открытом исходном коде намного раньше. Если бы в начале 2000-х годов PostgreSQL был расширен в открытом исходном коде поддержкой архитектуры без разделения ресурсов, вполне возможно, что направление больших данных с открытым исходным кодом развивалось бы совсем по-другому и более эффективно.</em><br><br></p><ol><li>Illustra была вторым крупным стартапом Стоунбрейкера, основанным в 1992 году для коммерциализации Postgres, поскольку компания RTI вывела Ingres на рынок.<br><br><em>Illustra было фактически третьим именем, предложенным для компании. Продолжая тему живописи, заданную названием Ingres, Illustra изначально называлась Miro. Из-за проблем с товарными знаками название было изменено на Montage, но оно также столкнулось с проблемами товарных знаков.</em><br><br>Команда основателей включала кое-кого из ядра команды Postgres, в том числе недавнего выпускника аспирантуры Вэя Хонга и тогдашнего главного программиста Джеффа Мередита, а также выпускников из Ingres Паулу Хоторн (Paula Hawthorn) и Майкла Убелла (Michael Ubell). Магистрант из Postgres Майк Олсон присоединился вскоре после основания, а я занимался в Illustra оптимизацией дорогостоящих функций в рамках моей кандидатской работы. В Illustra велись три основные работы: расширить SQL92 для поддержки пользовательских типов и функций, такой как в Postquel, сделать кодовую базу Postgres достаточно надежной для коммерческого использования и стимулировать рынок расширяемых серверов баз данных примерами расширений DataBlade — специализированными подключаемыми компонентами типов данных и функций. Illustra была приобретена Informix в 1997 году по оценочной стоимости 400 млн. долл. США [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#Mon96">Mon96</a>], а ее архитектура DataBlade была интегрирована в более устоявшийся код обработки запросов Informix как Informix Universal Server.</li><li>Netezza была стартапом, основанным в 1999 году, который разветвил код PostgreSQL для создания высокопроизводительного механизма параллельной обработки запросов на заказном оборудовании на основе FPGA. Netezza была довольно успешной независимой компанией, которая провела первую публичную продажу акций в 2007 году. В конечном итоге она был приобретена IBM за 1,7 млрд. долл. США [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#IBM10">IBM10</a>].</li><li>Greenplum предприняла первую попытку предложить параллельную горизонтально масштабирующуюся версию PostgreSQL без разделения ресурсов. Основанная в 2003 году, Greenplum ответвилась от публичного дистрибутива PostgreSQL, но в значительной степени сохранила API PostgreSQL, включая API для пользовательских функций. В дополнение к распараллеливанию, Greenplum расширила PostgreSQL альтернативным высокопроизводительным сжатым колоночным хранилищем и оптимизатором параллельных запросов, основанных на правилах, под названием Orca. Greenplum была приобретена EMC в 2010 году за 300 млн. долл. [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#Mal10">Mal10</a>], а в 2012 году EMC включила Greenplum в свою дочернюю компанию Pivotal. В 2015 году Pivotal решила снова выпускать Greenplum и Orca с открытым исходным кодом. Одним из достижений Greenplum по оптимизации Postgres API была библиотека MADlib для машинного обучения в SQL [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#HRS+12">HRS+12</a>]. MADlib живет сегодня как проект Apache. Еще одним интересным проектом с открытым исходным кодом, основанным на Greenplum, является Apache HAWQ, разработка компании Pivotal, которая запускает «верхнюю половину» Greenplum (т. е. обработчик параллельных запросов и интерфейсы прикладного программирования расширяемости PostgreSQL) над хранилищами больших данных, такими как файловая система Hadoop.</li><li>EnterpriseDB был создан в 2004 году как бизнес, основанный на ПО с открытым исходным кодом и продающий PostgreSQL как в базовом, так и в расширенном варианте и оказывающий связанные с этим услуги корпоративным клиентам. Ключевой особенностью улучшенного EnterpriseDB Advanced Server является совместимость базы данных с Oracle, обеспечивающая миграцию приложений из Oracle.</li><li>Компания Aster Data была основана в 2005 году двумя студентами Стэнфорда, чтобы создать параллельный движок для аналитики. Ее основной одноузловой движок был основан на PostgreSQL. Aster сосредоточилась на запросах к графам и на пакетах аналитики на основе пользовательских функций, которые можно было запрограммировать с помощью интерфейса SQL или MapReduce. Aster Data была приобретена компанией Teradata в 2011 году за 263 млн. долл. [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#Sho11">Sho11</a>]. Хотя Teradata никогда не интегрировала Aster в свой основной движок параллельных баз данных, она по-прежнему поддерживает Aster как автономный продукт для вариантов использования за пределами основного рынка хранилищ данных Teradata.</li><li>Компания ParAccel была основана в 2006 году, продавая параллельную версию PostgreSQL с колоночным хранилищем без разделения ресурсов. ParAccel расширила оптимизатор Postgres новыми эвристиками для запросов с большим количеством соединений. В 2011 году Amazon инвестировала в ParAccel, а в 2012 году анонсировала AWS Redshift — хранилище данных как сервис с размещением в публичном облаке на основе технологии ParAccel. В 2013 году ParAccel была приобретена компанией Actian (которая также приобрела Ingres) за нераскрытую сумму сделки, что означает, что это не было материальными затратами для Actian. Между тем предложение AWS Redshift имело огромный успех для Amazon — в течение многих лет это был самый быстрорастущий сервис хранилищ данных Amazon, и многие считают, что он готов вывести из бизнеса давно существующие продукты для хранилищ данных, такие как Teradata и Oracle Exadata. В этом смысле Postgres может достичь своего окончательного доминирования в облаке.</li><li>Компания CitusDB <em>(CitusDB — имя СУБД; компания называется Citus Data. — Прим. пер.)</em> была основана в 2010 году, чтобы предложить параллельную реализацию PostgreSQL без разделения ресурсов. Хотя она начиналась как ветвь PostgreSQL, с 2016 года CitusDB реализована через открытый API расширений PostgreSQL и может быть инсталлирована в базовую установку PostgreSQL. С 2016 года расширения CitusDB доступны в открытом исходном коде.</li></ol><h1>4. Уроки</h1><p>Вы можете извлечь множество уроков из успеха Postgres, некоторые из которых бросают вызов общепринятому мнению.<br><br>Урок высшего порядка, который я извлекаю, состоит в том, что Postgres бросил вызов «синдрому второй системы» (Second System Effect) по Фреду Бруксу (Fred Brooks) [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#Bro75">Bro75</a>]. Брукс утверждал, что дизайнеры вслед за успешной первой системой часто создают вторую, которая терпит неудачу из-за перегрузки возможностями и идеями. Postgres был второй системой Стоунбрейкера, и она, безусловно, была полна возможностей и идей. Система также успешно прототипировала многие идеи, при этом поставляя программную инфраструктуру, которая довела многие идеи до успешного завершения. Это не было случайностью — в своей основе Postgres был разработан с возможностью расширяемости, и этот дизайн был хорошо продуманным. С расширяемостью в качестве стержня архитектуры появилась возможность быть творческими и меньше беспокоиться о рамках: вы можете пробовать разные расширения, и пусть победит сильнейший. Сделанная хорошо, «вторая система» не обречена. Она выигрывает от доверия, любимых проектов и устремлений, сложившихся во время пользования первой системой. Это ранний архитектурный урок от более «серверно-ориентированной» школы разработки баз данных, которая бросает вызов устоявшемуся представлению «компонентно-ориентированной» школы разработки операционных систем.<br><br>Другой урок заключается в том, что акцент на универсальности, «один размер подходит всем», может быть выигрышным подходом как для исследований, так и для практики. Однако Стоунбрейкер времен МТИ <em>(В 2001 году Стоунбрейкер занял должность профессора информатики в Массачусетском технологическом институте (МТИ). — Прим. пер.)</em> наделал много шума в мире баз данных в начале 2000-х годов тезисом «один размер не всем подходит». Под этим знаменем он запустил флотилию важных проектов и стартапов, но ни один не мог тягаться размахом с Postgres. Кажется, что Стоунбрейкер времен Беркли бросает вызов более позднему опыту Стоунбрейкера времен МТИ, и я в этом не вижу проблем.<br><br><em>Как сказал Эмерсон (Ralph Waldo Emerson), «глупая последовательность — пугало мелких умишек».</em><br><br>Конечно, есть мудрость в девизе «один размер не всем подходит» (всегда можно найти скромные рынки для нестандартных решений), но успех системы, являющейся визитной карточкой Стоунбрейкера времен Беркли, далеко за пределами ее первоначальных целей, показывает, что подавляющее большинство проблем с базами данных вполне решаемы с помощью хорошей архитектуры общего назначения. Кроме того, проектирование этой архитектуры само по себе является технологической задачей и достижением. В конце концов, как и в большинстве научных и технических дебатов, есть не только один хороший способ что-то сделать. У обоих Стоунбрейкеров есть, чему научить нас. Но по натуре я все же поклонник более широкой программы, которую принял Стоунбрейкер времен Беркли.<br><br>Последний урок, который я извлекаю из Postgres, — это непредсказуемый потенциал, который может быть заложен в исследуемом вами открытом исходном коде. В своей Тьюринговской лекции Стоунбрейкер говорит об «интуитивной прозорливости» системы PostgreSQL, которая успешно развивается в открытом исходном коде, в основном благодаря людям не из окружения Стоунбрейкера. Вот цитата, которая звучит удивительно скромно:</p><blockquote>Команда добровольцев, подхвативших проект, ни один из которых не имеет ничего общего со мной или Беркли, присматривает за этой системой с открытым исходным кодом с 1995 года. Система Postgres, которую вы получаете из интернета, является результатом работы этой команды. Это открытый исходный код в лучшем виде, и я просто хочу упомянуть, что не имею ничего общего с этим и с этим группой людей, перед которыми мы все в огромном долгу. [<a href="https://habr.com/ru/companies/postgrespro/articles/438890/#Sto14">Sto14</a>]</blockquote><p>Я уверен, что все мы, кто написал открытый исходный код, хотели бы, чтобы такая «интуитивная прозорливость» пришла к нам. Но дело не только в «интуитивной прозорливости». Источник удачи коренится, несомненно, в устремлениях, широте и проницательности Стоунбрейкера в проекте и в команде, которую он курировал при создании прототипа Postgres. Если в этом есть какой-то урок, он может быть таким: «сделай что-то важное и отпусти это на волю». Мне кажется (учась у Стоунбрейкера), вы не можете пропустить ни одной части этого урока.</p><h1>5. Благодарности</h1><p>Я благодарен моим старым приятелям по Postgres Вэю Хонгу, Джеффу Мередиту и Майку Олсону за их воспоминания и информацию, а также Крейгу Керстиенсу (Craig Kerstiens) за его вклад в современный PostgreSQL.</p><h1>Литература</h1><ul><li><a name="Bro75"></a>[Bro75] Frederick P Brooks. The mythical man-month, 1975.</li><li><a name="Bro19"></a>[Bro19] Michael L. Brodie, editor. Making Databases Work. Morgan &amp; Claypool, 2019.</li><li><a name="DE19a"></a>[DE19a] DB-Engines. DB-Engines ranking, 2019. <a href="https://db-engines.com/en/ranking">db-engines.com/en/ranking</a>. (Last accessed January 4, 2019).</li><li><a name="DE19b"></a>[DE19b] DB-Engines. Method of calculating the scores of the DB-Engines ranking, 2019. <a href="https://db-engines.com/en/ranking_definition">db-engines.com/en/ranking_definition</a> (Last accessed January 4, 2019).</li><li><a name="DE19c"></a>[DE19c] DB-Engines. PostgreSQL is the DBMS of the year 2018, January 2019. <a href="https://db-engines.com/en/blog_post/79">db-engines.com/en/blog_post/79</a> (Last accessed January 4, 2019).</li><li><a name="DS08"></a>[DS08] David DeWitt and Michael Stonebraker. Mapreduce: A major step backwards. The Database Column, 1:23, 2008.</li><li><a name="Gut84"></a>[Gut84] Antonin Guttman. R-trees: A dynamic index structure for spatial searching. In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, SIGMOD ’84, pages 47–57, New York, NY, USA, 1984. ACM.</li><li><a name="HKM02"></a>[HKM<sup>+</sup>02] Joseph M. Hellerstein, Elias Koutsoupias, Daniel P. Miranker, Christos H. Papadimitriou, and Vasilis Samoladas. On a model of indexability and its bounds for range queries. J. ACM, 49(1):35–55, January 2002.</li><li><a name="HNP95"></a>[HNP95] Joseph M. Hellerstein, Jeffrey F. Naughton, and Avi Pfeffer. Generalized search trees for database systems. In Proceedings of the 21th International Conference on Very Large Data Bases, VLDB ’95, pages 562–573, San Francisco, CA, USA, 1995. Morgan Kaufmann Publishers Inc.</li><li><a name="HRS12"></a>[HRS<sup>+</sup>12] Joseph M Hellerstein, Christoper Re, Florian Schoppmann, Daisy Zhe Wang, Eugene Fratkin, Aleksander Gorajek, Kee Siong Ng, Caleb Welton, Xixuan Feng, Kun Li, et al. The MADlib analytics library: or MAD skills, the SQL. Proceedings of the VLDB Endowment, 5(12):1700–1711, 2012.</li><li><a name="IBM10"></a>[IBM10] IBM to acquire Netezza, September 2010. <a href="http://www-03.ibm.com/press/us/en/pressrelease/32514.wss#release">www-03.ibm.com/press/us/en/pressrelease/32514.wss#release</a> (Last accessed January 22, 2018).</li><li><a name="KMH97"></a>[KMH97] Marcel Kornacker, C. Mohan, and Joseph M. Hellerstein. Concurrency and recovery in generalized search trees. In Proceedings of the 1997 ACM SIGMOD International Conference on Management of Data, SIGMOD ’97, pages 62–72, New York, NY, USA, 1997. ACM.</li><li><a name="Mal10"></a>[Mal10] Om Malik. Big Data = Big Money: EMC Buys Greenplum. In GigaOm, July 2010. <a href="https://gigaom.com/2010/07/06/emc-buys-greenplum/">gigaom.com/2010/07/06/emc-buys-greenplum</a>.</li><li><a name="Mon96"></a>[Mon96] John Monroe. Informix acquires illustra for complex data management. In Federal Computer Week, January 1996.</li><li><a name="OFS83"></a>[OFS83] James Ong, Dennis Fogg, and Michael Stonebraker. Implementation of data abstraction in the relational database system ingres. ACM Sigmod Record, 14(1):1–14, 1983.</li><li><a name="Ols93"></a>[Ols93] Michael A. Olson. The design and implementation of the inversion file system. 1993.</li><li><a name="SAHR84"></a>[SAHR84] Michael Stonebraker, Erika Anderson, Eric Hanson, and Brad Rubenstein. Quel as a data type. In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, SIGMOD ’84, pages 208–214, New York, NY, USA, 1984. ACM.</li><li><a name="Sho11"></a>[Sho11] Erick Shonfeld. Big pay day for big data. teradata buys aster data for $263 million. In TechCrunch, May 2011. <a href="https://techcrunch.com/2011/03/03/teradata-buys-aster-data-263-million/">techcrunch.com/2011/03/03/teradata-buys-aster-data-263-million</a> (Last accessed January 22, 2018).</li><li><a name="SHWK76"></a>[SHWK76] Michael Stonebraker, Gerald Held, Eugene Wong, and Peter Kreps. The design and implementation of ingres. ACM Transactions on Database Systems (TODS), 1(3):189–222, 1976.</li><li><a name="SK91"></a>[SK91] Michael Stonebraker and Greg Kemnitz. The postgres next generation database management system. Commun. ACM, 34(10):78–92, October 1991.</li><li><a name="SR86"></a>[SR86] Michael Stonebraker and Lawrence A. Rowe. The design of postgres. In Proceedings of the 1986 ACM SIGMOD International Conference on Management of Data, SIGMOD ’86, pages 340–355, New York, NY, USA, 1986. ACM.</li><li><a name="SRG83"></a>[SRG83] M Stonebraker, B Rubenstein, and A Guttman. Application of abstract data types and abstract indices to cad bases. IEEE Trans, on Software Engineering, 1983.</li><li><a name="Sto86"></a>[Sto86] Michael Stonebraker. The case for shared nothing. IEEE Database Eng. Bull., 9(1):4–9, 1986.</li><li><a name="Sto87"></a>[Sto87] Michael Stonebraker. The design of the postgres storage system. In Proceedings of the 13th International Conference on Very Large Data Bases, VLDB ’87, pages 289–300, San Francisco, CA, USA, 1987. Morgan Kaufmann Publishers Inc.</li><li><a name="Sto95"></a>[Sto95] Michael Stonebraker. An overview of the sequoia 2000 project. Digital Technical Journal, 7(3):39–49, 1995.</li><li><a name="Sto14"></a>[Sto14] Michael Stonebraker. The land sharks are on the squawk box, 2014. <a href="https://www.acm.org/turing-lecture-stonebraker">www.acm.org/turing-lecture-stonebraker</a> (Last accessed January 4, 2019).</li></ul>	2023-11-12 12:34:55.180204+00	2023-11-12 12:34:55.180204+00
64	be9ef417-bdd1-458f-b08a-5b5c8a118aab	2	DZ Online Tech: Postgres Professional	<p>Привет.<br><br>В прошлом году я начал снимать серию передач/интервью на тему цифровой трансформации бизнеса (<a href="https://www.youtube.com/channel/UCJuwCFeP6rhSUqk9gRMAwuw">они тут, кому интересно — подписывайтесь</a>). Эти передачи были на стыке IT и бизнеса, но, всё же, больше про бизнес.<br><br>В процессе стало понятно, что есть немало тем, которые имеют существенную глубину с программерской точки зрения. И в этом году мы начали снимать серию интервью под общим лейблом «DZ Online Tech» — теперь уже с упором на то, что под капотом. Ну и поскольку видео всем смотреть лень, конечно, эти интервью расшифровываются, и сегодня я публикую первое — с Иваном Панченко из Postgres Professional.<br><br>Кому интересен оригинал — <a href="https://www.youtube.com/watch?v=YmePVl2FCcM">вот он</a></p><p>(Ну и, кстати, я не могу поклясться, что все выпуски будут выходить в расшифровке, так что если понравилось — подписывайтесь на ютубе, туда всё приходит раньше и гарантированно.)<br><br><u>Для тех, кто любит читать — расшифровка:</u></p>	<p><strong>Добрый день, Иван. Postgres массово воспринимается как инструмент импортозамещения. И самым известным драйвером его применения является идея «давайте заменим какую-нибудь западную СУБД на Postgres». При этом известно, что у него есть достаточно много собственных ценностей. Я бы хотел по ним кратко пройтись. Если мы выбираем, не глядя «импорт — не импорт», а с чистого листа — почему так?</strong><br><br>Добрый день. Во-первых, большинство выбирает Postgres не из-за импортозамещения. Понятно, что действительно есть государственные меры, ограничения импорта иностранного софта. Postgres Pro есть в реестре, поэтому он пригоден для импортозамещения. На самом деле, это мировая тенденция все больше выбирать Postgres. Мы видим только ее отражение. Возможно то, что у нас выразилось в импортозамещении, на самом деле, следствие каких-то более глубинных, фундаментальных процессов.<br><br>Postgres созрел. Это хорошая альтернатива более старым коммерческим базам данных. Во всем мире сейчас понимают, что Postgres — это продукт такого же класса, как киты: Oracle, Microsoft SQL Server и DB2, про последний из которых уже почти забыли, но тем не менее, это хороший продукт.<br><br>Но, так или иначе, DB2 постепенно куда-то уплывает из рынка, а Oracle, Microsoft SQL на нем есть. И Postgres — это что-то третье, что сейчас в мировом масштабе вплывает в рынок. Надо сказать, что вплывает достаточно давно — 10 лет назад, когда в Postgres появилась хорошая поддержка Windows. Когда в нем появилась репликация, его начали воспринимать; о нем начали говорить как о базе данных для бизнеса, промышленности и чего-то серьезного.<br><br><strong>Ты сейчас все равно говоришь в картине «были два хороших, есть еще один неплохой». Но наверняка есть вещи, которые его ставят вперед и заставляют предпочитать его остальным.</strong><br><br>Да, таких вещей несколько. Во-первых, это то, что Postgres является опенсорсным (open source) продуктом со специфической лицензией. При этом у него есть коммерческие клоны. Один из них наш. Но то, что он происходит от опенсорсного продукта — это само по себе является большим преимуществом.<br><br>Вторая тема, что Postgres — это база данных с высокой степенью расширяемости. Это тоже было драйвером его развития.<br><br>Надо сказать, что степень расширяемости Postgres — это как раз то место, где наш русский вклад наиболее заметен. Последние 15-17 лет наша команда занимается в основном механизмами расширяемости.<br><br>Например, в Rambler в 2000 году, где я впервые работал вместе с моими нынешними коллегами по компании, мы использовали расширяемость Postgres для того, чтобы поднять производительность новостной службы Rambler в 30 раз. Как? Мы —программисты, владеющие языком C и умеющие читать документацию. Эти две вещи позволили нам создать новый тип индексов для быстрого поиска по массивам, что выходит за рамки классической реляционной модели, но полезно.<br><br>В частности, в Rambler замена лишнего джоина (join) на массив, в котором можно искать по хитрому индексу, в 30 раз повысила производительность. Надо понимать, что тогда все контентные проекты Rambler крутились на машинках, чья мощность не превышала мощности современного смартфона: Pentium 2, 400 МГц, 500 Мб памяти. Если повезет, то Pentium 3 (он тогда появился) до 800 МГц. Таких Pentium 3 могло быть 2 штуки в сервере. И на всем этом обслуживались миллионы запросов.<br><br>Понятно, что тогда приходилось весьма серьезно оптимизировать код, иначе это все бы не работало. Помогла расширяемость Postgres. Посидели, подумали, и в приемлемые сроки, можно сказать за месяц, сделали то, что потом легло в основу всего, что сейчас есть в Postgres, связанного с JSON, с полнотекстовым поиском.<br><br>Благодаря этому в Postgres достаточно быстро появилась поддержка слабоструктурированных данных. Что это такое? Это ключ-значения, грубо говоря. В 2004 году нами было сделано в Postgres расширение Hstore для хранения внутри одного поля базы данных информации типа ключ-значения. Тогда это был еще не JSON, он зашел в моду потом. А тогда был Hstore. Почему Hstore? Мы смотрели на Perl, в котором есть хэш (hash), и вот мы хэш с практически таким же синтаксисом сделали в Postgres.<br><br>Вначале эта штука существовала как отдельный экстеншн (extension), потом была закоммичена (commit) в основной набор того, что входит в Postgres. И она была столько же популярна. То есть JSON обогнул ее по популярности совсем недавно.<br><br><strong>Получается, что вы в некотором смысле поставили точку в этом дурацком обсуждении SQL и noSQL, создав СУБД, которая обладает свойствами и того и другого одновременно.</strong><br><br>В каком-то смысле, да. Из noSQL мы взяли хорошее, а именно сравнительную гибкость, при этом без потери транзакционности, без потери целостности данных и всего, что бывает обычно в нормальных СУБД.<br><br>Итак, Hstore. Но Hstore был одноуровневым. То есть хэш одноуровневый. Это не JSON, просто хэш. И плюс массивы в Postgres были до нас. Мы сделали поддержку индексов, то есть можно было достаточно быстро искать по тому, что входит в массивы, и по тому, что лежит внутри Hstore, как по ключам, так и по значениям. Вот это полезная вещь. Народ ей начал пользоваться по всему миру. Потом появился JSON. Он появились недавно, году в 2011-2012 в Postgres. Было три разных попытки его реализовать. Потом все эти попытки выкинули, и сделали другим способом. Вначале JSON просто был текстом, который лежит в специальном поле.<br><br><strong>Это ваша команда делала JSON?</strong><br><br>Нет, наша команда сделала для JSON важную вещь. Когда JSON появился в Postgres, это было просто текстовое поле, и для того чтобы извлечь оттуда что-нибудь, какое-нибудь значение поиска приходилось каждый раз парсить JSON. Конечно, это работало медленно, но позволяло хранить многоуровневые данные.<br><br>Но в таком текстовом поле смысла немного. Я, например, в своих проектах и так хранил в текстовых полях слабоструктурированные данные, просто не называя это полем специального типа. Но вопрос в том, что с этим JSON надо было еще и эффективно работать. И то, что мы сделали уже своей командой в 2014 году — это JSON-B.<br><br>Он быстрее за счет того, что уже разложен и распаршен (parsing). Распаршен так, чтобы быстро можно было по ключу достать значение. Когда мы сделали JSON-B, прикрутили к нему возможность искать по индексам, тогда он стал действительно популярным.<br><br><strong>Окей. Возвращаясь к специфическим свойствам: что еще есть такого, что отличает Postgres от других СУБД и является причиной применять его?</strong><br><br>Все, что мы так долго говорили про JSON — все это проявление гибкости Postgres. В нем есть много мест, в которых его можно расширять. Другая сторона гибкости — это поддержка геоданных. Ровно так же, как были сделаны специальные индексы, например, для поиска по JSON, по массивам и по текстам, примерно через то же самое место было сделаны индексы для быстрого поиска по геоинформации, по пространственным данным. Там мы тоже приложили свою достаточно большую русскую руку к этому делу.<br><br>В результате — PostGIS, это такой очень распространенный в мире способ работы с геоинформационными данными.<br><br><strong>Пользователи разрабатывают для Postgres экстеншены под свои проекты? Это существенный объем его применения?</strong><br><br>Нет, естественно, это какие-то «сливки» сверху. Есть люди, которым это становится нужно, потому что их задача дорастает до этого. Это, прежде всего, универсальная база данных, которая очень хорошо поддерживает все стандарты и которая уж точно подойдет практически для любой задачи.<br><br>Если вы начинаете стартап, например — возьмите Postgres, не ошибетесь. Потому что, во-первых, он функционально расширяем. А во-вторых, если вы используете его опенсорсную версию, то не становитесь заложником лицензии, которую надо приобретать.<br><br><strong>Тебе как сотруднику коммерческой копании говорить это, наверное, не очень радостно?</strong><br><br>Это законы природы, против которых не попрешь. Есть open source, и есть бизнес на open source. И это достаточно необычная вещь, отличающаяся от обычного бизнеса. Но в будущем роль open source, судя по всему, будет расти. По крайней мере, это видно по успеху Postgres и по надоевшему всем графику Gartner, что опенсорсная база данных все чаще и чаще используется, и никуда от этого не деться.<br><br><img src="https://habrastorage.org/r/w1560/webt/5o/hw/1s/5ohw1s-ug9fpqrlf-nizwlvltw0.jpeg" data-src="https://habrastorage.org/webt/5o/hw/1s/5ohw1s-ug9fpqrlf-nizwlvltw0.jpeg"><br><br><strong>Вы как компания, зачем вы нужны? Вот он опенсорс: пошел, скачал и все хорошо же?</strong><br><br>На самом деле, пошел, скачал, но уткнулся в проблему. Рано или поздно люди утыкаются в проблему. Понятно, что большинству пользователей подойдет опенсорсная версия. У них не будет проблем, у них небольшие базы, они не вырастут. Но в некоторых случаях нужна помощь профессионала.<br><br>Раньше модель была простой. В данном случае я говорю о Postgres, потому что разные продукты находятся на разных стадиях этого эволюционного пути. Postgres изначально был просто университетским проектом. Люди не думали о деньгах; им было интересно решить задачу. Потом он был добровольческим проектом: люди делали для себя. При этом они работали в каких-то компаниях, как наша.<br><br><strong>Ну, как вы в Rambler сделали решение.</strong><br><br>Rambler — хороший пример. Мы сделали, потому что нам это было надо. Нас совершенно не волновали бизнес-пользователи. Нужно ли это кому-то еще или нет.<br><br>Postgres-компании вначале стали возникать не в России, а в других странах. Впервые такая компания возникла в Японии, правда, на деньги Fujitsu. Там было инвестировано достаточно много. И она начала заниматься разработкой в Postgres и около-Postgres вещей. Потом в достаточно короткий срок после этого появился второй квадрант (2nd Quadrant) в Англии, и в Америке Enterprise DB. Это все компании, которые зарабатывают на Postgres. Все эти компании начинают с того, что они исполняют заказы. Они занимаются…<br><br><strong>Заказной разработкой.</strong><br><br>Заказной разработкой на уровне СУБД. Мы тоже этим занимаемся, и занимались такими вещами, когда еще не были компанией, потому что Postgres расширяем. «Нам надо, чтобы полнотекстовый поиск искал не только вот так, но еще и правильным образом игнорировал наши французские акценты, или наши немецкие умлауты. Доделайте это — мы вам заплатим». Или: «JSON — очень хорошая штука. Вот бы к нему приделать индекс. И тогда наш портал бесплатных объявлений будет летать чуточку быстрее, чем все остальные».<br><br>Вот такие ребята действительно финансировали разработку, платя отдельным разработчикам или в некоторых случаях заказывая молодым, только что появившимся компаниям какие-то фичи, которые хотелось получить. А потом постепенно начала возникать потребность в коммерческих версиях Postgres.<br><br>Почему, и вообще, откуда взялись эти коммерческие форки (fork)? Прежде всего, надо сказать, что у Postgres такая хитрая лицензия, которая легально позволяет делать из него коммерческий продукт. BSD-подобная лицензия. Это никакой не GPL. Вы можете взять хотя бы тот же код, хоть даже не внося в него никаких изменений, оставить там две строчки из лицензионного соглашения, дописать к нему еще что-нибудь свое, и написать, что это мой «Вася Пупкин DB» и я ее продаю. Пойти на базар и продавать хоть за миллиарды — пожалуйста, не важно. Купит хоть кто-нибудь у Васи Пупкина «Вася Пупкин DB» или нет — это отдельный вопрос. Скорее всего, нет. А если он туда привнесет что-то свое? И этим начали заниматься.<br><br>У нас есть такая картинка, где зелеными и красными флажочками обозначены коммерческие и некоммерческие форки Postgres. Их достаточно много. Мы насчитали 40-50 штук. Большинство из них, естественно, не успешные: они загибаются, о них забывают. Какие-то большие организации, типа Amazon или Salesforce, могут сделать форк для себя, например. Самые известные коммерческие форки — это, конечно, Greenplum, EnterpriseDB. В том числе, наш Postgres Pro, японский Fujitsu Enterprise Postgres.<br><br><img src="https://habrastorage.org/r/w1560/webt/yi/iq/2c/yiiq2cbhpwjcacsn0vvk4lfleek.png" data-src="https://habrastorage.org/webt/yi/iq/2c/yiiq2cbhpwjcacsn0vvk4lfleek.png"><br><br>Англичане тоже совсем недавно enterprise-версию Postgres сделали. Для чего? Есть специализированные форки, например, Greenplum — это база данных для массивных аналитических расчетов с большим параллелизмом. Они взяли Postgres примерно десятилетней давности, очень сильно изменили планировщик, дописали туда работу с распределенными запросами, правда, потеряв при этом транзакционную целостность. Но для аналитических баз это неважно: там все уже лежит, и надо собрать и правильным образом распределить запрос по серверам. Они сделали Greenplum.<br><br>Эта штука используется, в том числе, и у нас в России. В частности, «Тинькофф Банк» хвастался, что у них это есть. Хорошая вещь, которая имела определенный коммерческий успех, но отстала от open source, потому что имела большой уровень несовместимости. Они очень сильно поменяли планировщик, сделали много хорошего, конечно, за это их можно похвалить, но развитие open source ушло в другую сторону. А тут главное не отойти далеко. Чем дальше отходишь, тем труднее потом мерджить.<br><br><strong>Первый пример — это когда сделали версии Postgres, которые обладают некоторой специфической функциональностью. Это один из примеров, почему коммерческие компании возникают. А какие еще есть?</strong><br><br>Greenplum сделали действительно крупную функциональную вещь, которая отодвигает Postgres сильно вбок. При этом это уже не универсальный продукт, но хорошо решающий важную востребованную задачу.<br><br>Другая группа форков — это к которой как раз относится наш Postgres Pro и Enterprise DB. Последние, как ни странно, несмотря на всю свою американскую природу, занимаются миграцией с Oracle.<br><br>В Америке тоже переходят с Oracle, потому что дорого платить за каждый «чих». Не все хотят так, и не у всех есть чем платить. Поэтому Enterprise DB предлагает по всему миру услуги по миграции с Oracle. И для того, чтобы проще переползать, они пошли по пути реализации в Enterprise DB каких-то фичей, которые есть в Oracle.<br><br>А что такое наш Postgres Pro? Мы решили не идти по этому пути, хотя какие-то фичи из Oracle, например, асинхронные автономные транзакции, мы тоже сделали. Но в большой перспективе мы не видим путь следования за Oracle. Потому что «следовать за» значит, что вы всегда будете отставать, и все равно никогда не будете 100% совместимыми, и все равно придется постоянно доказывать свою хотя бы частичную совместимость. Это сложная проблема.<br><br>Несмотря на то, что вы можете написать парсер Oracle'ового языка PSQL; слава богу, он документирован синтаксически, но очень строгой документации на его семантику вы не найдете. Более того, для полной совместимости вам придется воспроизводить «баг в баг». Вот попробуйте сделать это, и потом докажите, что это действительно так. Мы поняли, что на самом деле это полностью не решает проблему миграции. Мы решили, что лучше двигаться вперед. Лучше просто делать лучший продукт.<br><br><strong>С другой стороны, обязательно ли в такой картине делать совместимость на уровне полного покрытия, я уж не говорю про «баг в баг»? Задача заключается в том, чтобы закрыть условные 80% расходов при миграции.</strong><br><br>Это действительно так кажется, но на практике окажется, что когда вы мигрируете систему, это выглядит следующим образом: вам дают готовую систему. Это черный ящик, завернутый в черную бумагу, перевязанный черной веревочкой. Вы не знаете, что внутри. Есть ли там эти 80% или она чуть-чуть вылезает? Очень часто бывает так, что разработано методом «тяп-ляп» в 3 этажа, и строители первого этажа уже давно канули куда-то.<br><br>И поэтому, чтобы мигрировать в эту штуку, вам приходится делать reverse engineering — даже не для того, чтобы переписать, а для того, чтобы понять, работает она или нет. То есть, если у вас есть идеальное тестовое покрытие — тогда да, вы можете говорить…<br><br><strong>Чего не бывает никогда, конечно же..</strong><br><br>…Вы можете говорить: «Заменяем движок, запускаем тесты. 100% прошло, все верифицировано. Поехали». В реальности так не бывает. Это идеальный случай. И поэтому оказывается, что вы реализуете на 80%, а остальным все равно будете мучиться, причем заранее вы не знаете с чем. У миграции есть другие, гораздо более весомые проблемы.<br><br>У каждого продукта, у каждой СУБД есть достоинства. У Postgres, например, это работа с JSON и с массивами, о которых мы говорили. Многие вещи, которые на Oracle оптимально пишутся вот так, на Postgres оптимально пишутся по-другому. Поэтому, если вы будете мигрировать «в тупую», то вы получите минимально работающее подмножество, совместимое и с тем, и с другим. Вы не будете использовать преимущества ни старой базы данных, ни новой.<br><br><strong>Давай два слова о будущем. Куда все это идет? Убьете ли вы всех конкурентов?</strong><br><br>Я не думаю, что мы убьем всех конкурентов. В принципе, у нас такие хорошие, «ласковые» цели. Мы пришли не убивать, а строить. Наша задача — создать очень хорошую базу данных. Желательно лучшую.<br><br><strong>А что это такое? Каков критерий этой хорошести? Я сомневаюсь в том, что у Microsoft задача сделать очень плохую базу данных.</strong><br><br>Да, естественно, все к этому идут. Поэтому в мире баз данных сейчас есть какие-то тенденции. А поскольку объемы данных растут быстрее, чем все остальное, соответственно, основная тенденция баз данных сейчас — это распределенность. Те, кто лучше будут решать задачу распределенной базы данных — те будут молодцы.<br><br><strong>С нами был Иван Панченко. Спасибо, Иван.</strong><br><br>Спасибо.</p>	2023-11-12 12:47:43.404671+00	2023-11-14 00:09:02.75261+00
65	8cb09936-0348-4dcf-9fce-5902a8e8fe23	2	PHP и Laravel дайджест новостей за октябрь 2023 года	<p>Всем привет! Краткий обзор новостей из мира PHP и Laravel за октябрь 2023 г.</p>	<h2>PHP Дайджест</h2><p><strong>Вышли </strong><a href="https://www.php.net/ChangeLog-8#8.1.25" rel="noopener noreferrer nofollow"><strong><u>PHP 8.1.25</u></strong></a><strong> и </strong><a href="https://www.php.net/ChangeLog-8#8.2.12" rel="noopener noreferrer nofollow"><strong><u>PHP 8.2.12</u></strong></a></p><p>В этих выпусках несколько исправлений ошибок и улучшений в модулях Core, CLI, CType, DOM, Fileinfo, Filter, Hash, Intl, MySQLnd, Opcache, PCRE, SimpleXML, Streams, XML и XSL.</p><p><a href="https://www.php.net/archive/2023.php#2023-10-26-1" rel="noopener noreferrer nofollow"><strong><u>Вышел пятый релиз кандидат PHP 8.3.0</u></strong></a></p><p>Очередной релиз-кандидат вышел в соответствии с <a href="https://wiki.php.net/todo/php83" rel="noopener noreferrer nofollow"><u>графиком</u></a>. Шестой RC ожидается 9 ноября и станет последним перед финальным релизом PHP 8.3.</p><p>Подробный список того, что появится в PHP 8.3, можно найти на сайтах <a href="https://php.watch/versions/8.3" rel="noopener noreferrer nofollow"><u>php.watch</u></a> или <a href="https://stitcher.io/blog/new-in-php-83" rel="noopener noreferrer nofollow"><u>stitcher.io</u></a>.</p><p><a href="https://github.com/SjonHortensius/phpshell/" rel="noopener noreferrer nofollow"><strong><u>SjonHortensius/phpshell</u></strong></a><strong> стал публичным</strong></p><p>Репозиторий phpshell, на базе которого работает сайт <a href="https://3v4l.org/" rel="noopener noreferrer nofollow"><u>3v4l.org</u></a> стал общедоступен.</p><p><a href="https://web.archive.org/web/20080915154420/http://trac.symfony-project.org/changeset/1" rel="noopener noreferrer nofollow"><strong><u>Symfony исполнилось 18 лет</u></strong></a></p><p>18 октября 2005 года был сделан первый публичный коммит проекта Symfony.</p><p><a href="https://blog.jetbrains.com/phpstorm/2023/10/the-phpstorm-2023-3-early-access-program-is-now-open/" rel="noopener noreferrer nofollow"><strong><u>Открыта программа раннего доступа PhpStorm 2023.2</u></strong></a></p><p>В первой версии EAP улучшена поддержка PHP 8.3, добавлен мастер создания новых проектов для Symfony и поддержку преобразования аннотаций Doctrine в атрибуты.</p><h3>Ядро PHP</h3><p>Большинство новостей ядра PHP подробно освещаются в серии <a href="https://thephp.foundation/blog/tag/roundup/" rel="noopener noreferrer nofollow"><strong><u>PHP Core Roundup</u></strong></a> от PHP Foundation, мы лишь быстро по ним пробежимся:</p><p>📣<a href="https://wiki.php.net/rfc/integer-rounding" rel="noopener noreferrer nofollow"><strong><u>RFC: Rounding Integers as int</u></strong></a></p><p>На данный момент функции округления round, ceil и floor возвращают число с плавающей точкой, но при использовании целых чисел выше 2^53 получаются неожиданные результаты из-за потери точности. Marc Bennewitz предлагает выполнять округление для заданного целого числа и возвращать полученное целое число, если это возможно.</p><p><strong>📣</strong><a href="https://wiki.php.net/rfc/unbundle_imap_pspell_oci8" rel="noopener noreferrer nofollow"><strong><u>RFC: Unbundle ext/imap, ext/pspell, ext/oci8, and ext/PDO_OCI</u></strong></a></p><p>Derick Rethans предлагает удалить модули из ядра PHP и перенести в репозиторий PECL.</p><p><strong>📣</strong><a href="https://wiki.php.net/rfc/mb_trim" rel="noopener noreferrer nofollow"><strong><u>RFC: Multibyte for trim function mb_trim, mb_ltrim and mb_rtrim</u></strong></a></p><p>Yuya Hamada предлагает добавить многобайтовую поддержку для функций обрезки.</p><p><strong>📣</strong><a href="https://wiki.php.net/rfc/rfc1867-non-post" rel="noopener noreferrer nofollow"><strong><u>RFC: RFC1867 for non-POST HTTP</u></strong></a></p><p>RFC1867 определяет тип контента multipart/form-data. PHP поддерживает анализ этого типа контента, но только для POST-запросов. Если осуществляется POST-запрос и тип содержимого multipart/form-data, тело запроса немедленно обрабатывается перед запуском PHP-скрипта и заполняется в суперглобальные переменные $_POST и $_FILES. Эта функция запускается автоматически и не предоставляется непосредственно пользователю.</p><p>Ilija Tovilo предлагает добавить новую функцию request_parse_body(), чтобы вывести существующую функциональность на пользовательский уровень и использовать ее для других HTTP-методов.</p><p><strong>📣</strong><a href="https://wiki.php.net/rfc/change_the_edge_case_of_round" rel="noopener noreferrer nofollow"><strong><u>RFC: Change the edge case of round()</u></strong></a></p><p>Saki Takamachi предлагает изменить поведение функции round в крайних случаях и перестать ожидать от чисел с плавающей точкой десятичного поведения и начать ожидать, что числа с плавающей точкой будут вести себя как числа с плавающей точкой.</p><p>✅<a href="https://wiki.php.net/rfc/bcrypt_cost_2023" rel="noopener noreferrer nofollow"><strong><u>RFC: Increasing the default BCrypt cost</u></strong></a></p><p>RFC о котором мы говорили в прошлом выпуске принят единогласно. Большинством голосов было принято, что в PHP 8.4 значение cost по умолчанию будет увеличено до 12.</p><p>✅<a href="https://wiki.php.net/rfc/jit-ir" rel="noopener noreferrer nofollow"><strong><u>RFC: A new JIT implementation based on IR Framework</u></strong></a></p><p>Ещё один RFC из прошлого выпуска также принят единогласно в обоих голосованиях: в PHP 8.4 появится новая реализация JIT, тем временем старая реализация будет удалена.</p><h2>Laravel дайджест</h2><h3>Laravel дайджест</h3><h4>Обновления Laravel</h4><p>В этом месяце вышло три релиза (10.26 - 10.28). Они большие, но в основном это фиксы - где-то что-то поправили - в док-блоках, в аннотациях и добавили тесты. В Git workflow обновили Git auto-commit action с четвертой на пятую версию.</p><p><strong>10.26. Vendor::Publish prompt</strong></p><p>Взглянем на поиск в команде vender::publish. Бывает, что в огромном списке нужно выбрать определённую цифру и указать, что именно из vendor service provider необходимо опубликовать. Теперь есть vendor publish с новым Laravel Prompt, где появился поиск. Теперь быстро можно найти что нам требуется и сразу опубликовать все необходимые файлы от vendor service provider. С таким поиском передавать опцию с namespace провайдера больше не надо.</p><p><strong>10.26. Route::List -vv option</strong></p><p>Прокачали artisan команду Route::list. Появилась опция -vv, которая выведет развёрнутую информацию по применённым к роутам мидлварам.</p><p><a href="https://artisan.page/" rel="noopener noreferrer nofollow"><strong><u>Artisan.page</u></strong></a></p><p>Вышел проект по Artisan-командам в Laravel. На нём собраны все Artisan команды и все возможные опции и аргументы которые у них есть. Многих из них нет в официальной документации, а на этом сайте есть! Реализована удобная навигация. Для тех, кто любит быстро и удобно что-то генерировать в одну команду.</p>	2023-11-12 12:57:52.606231+00	2023-11-12 12:58:22.569153+00
68	bc7c27e3-c199-4e04-ad8e-748520775959	2	Специалисты Microsoft не будут заниматься поддержкой PHP 8.0 для Windows	<p><img src="https://habrastorage.org/r/w1560/webt/r2/wl/yt/r2wlytgaz9nux6gbvbrhl8slxpc.jpeg" data-src="https://habrastorage.org/webt/r2/wl/yt/r2wlytgaz9nux6gbvbrhl8slxpc.jpeg"><br>9 июля 2020 года сервисный инженер и менеджер по проектам PHP в Microsoft Дейл Хирт (Dale Hirt) <a href="https://news-web.php.net/php.internals/110907" rel="nofollow">предупредил</a> сообщество разработчиков PHP, что компания не собирается заниматься поддержкой новых версий PHP, включая 8.0 и выше, для Windows.</p>	<p>В настоящее время специалисты Microsoft занимаются поддержкой, исправлением ошибок и элементами безопасности версий PHP 7.2, 7.3 и 7.4 для Windows. Причем поддержка PHP 7.2 закончится в ноябре этого года, а PHP 7.3 и 7.4 еще будут поддерживаться Microsoft не менее года.<br><br>Представитель сообщества разработчиков PHP <a href="https://news-web.php.net/php.internals/110908" rel="nofollow">ответил</a> Microsoft, что сообщество глубоко признательно компании за проделанную их специалистами работу по поддержке <a href="https://windows.php.net/" rel="nofollow">PHP на Windows</a> на протяжении многих лет. Также в сообществе разработчиков PHP сообщили, что примут все необходимые меры, чтобы найти в ближайшее время альтернативный вариант для организации поддержки PHP 8.0 и выше для Windows, например, своими силами.<br><br>На текущий момент идет <a href="https://www.php.net/archive/2020.php#2020-06-25-1" rel="nofollow">альфа-тестирование</a> ветки PHP 8.0. Уже выпущены 8.0.0 alpha1 и alpha2. Официальный выход PHP 8.0 ожидается в ноябре этого года.<br><br></p><blockquote>См. также:<br><br><ul><li>«<a href="https://habr.com/ru/news/t/509968/">WindowsLatest: Microsoft планирует постепенно убрать из Windows 10 панель управления</a>»</li><li>«<a href="https://habr.com/ru/news/t/509252/">В Windows 10 Developer Preview 20161 показали обновления меню «Пуск» и режима миниатюр в Edge</a>»</li></ul></blockquote>	2023-11-12 17:01:13.242628+00	2023-11-12 17:01:13.242628+00
66	56aa064d-a0e9-41b1-ac74-23aae03fb362	2	Состоялся релиз языка программирования PHP 8.0	<p>26 ноября 2020 года <a href="https://www.php.net/archive/2020.php#2020-11-26-3" rel="nofollow">состоялся</a> релиз языка программирования PHP 8.0.<br><br>Сообщество разработчиков <a href="https://www.php.net/releases/8.0/ru.php?lang=ru" rel="nofollow">пояснило</a>, что новая версия языка PHP содержит множество новых возможностей и оптимизаций, включая именованные аргументы, Union type, атрибуты, упрощенное определение свойств в конструкторе, выражение Match, оператор Nullsafe, добавлено включение JIT-компилятора и сделаны улучшения в системе типов, сравнении строк и чисел, обработке ошибок и консистентности.</p>	<p>Новая версия языка программирования PHP содержит ряд <a href="https://www.php.net/manual/ru/migration80.new-features.php" rel="nofollow">новых функций</a>. Часть ранее используемых в предыдущих версиях PHP функций <a href="https://www.php.net/manual/ru/migration80.deprecated.php" rel="nofollow">объявлены устаревшими</a>.<br><br>Разработчики внесли в PHP 8.0 некоторые изменения, <a href="https://www.php.net/manual/en/migration80.incompatible.php" rel="nofollow">нарушающие обратную совместимость</a> с предыдущими версиями языка программирования.<br><br>Для миграции с PHP 7.4.x на PHP 8.0.x создан <a href="https://www.php.net/manual/ru/migration80.php" rel="nofollow">специальный раздел</a> на портале php.net. Разработчики просят ознакомиться с документацией и изменениями в PHP 8.0 перед переходом на новую версию, особенно в производственной среде.<br><br>Примечательно, что в начале июля 2020 года сервисный инженер и менеджер по проектам PHP в Microsoft Дейл Хирт (Dale Hirt) <a href="https://habr.com/ru/news/t/510522/">предупредил</a> сообщество разработчиков PHP, что компания не собирается заниматься поддержкой новых версий PHP, включая 8.0 и выше, для Windows. Представитель сообщества разработчиков PHP ответил Microsoft, что они глубоко признательны компании за проделанную их специалистами работу по поддержке PHP на Windows на протяжении многих лет. Также в сообществе разработчиков PHP сообщили, что примут все необходимые меры, чтобы найти в ближайшее время альтернативный вариант для организации поддержки PHP 8.0 и выше для Windows, например, своими силами.</p>	2023-11-12 16:57:48.124871+00	2023-11-12 17:10:32.005969+00
69	d1b6895d-b966-4664-ac1c-b774fe9f61a4	2	Выявлена уязвимость PHP 7, которая помогает перехватывать контроль над NGINX-серверами	<p><img src="https://habrastorage.org/r/w1560/webt/qb/nq/8f/qbnq8fosn7wvlmb9kl3wpdt4ulg.jpeg" alt="image" data-src="https://habrastorage.org/webt/qb/nq/8f/qbnq8fosn7wvlmb9kl3wpdt4ulg.jpeg">Эксперты <a href="https://bugs.php.net/bug.php?id=78599">обнаружили в ветке PHP 7 уязвимость CVE-2019-11043</a>, которая позволяет хакерам выполнять команды на сервере с помощью специально сформированного URL с добавлением '?a='.<br><br>Данный баг активно применяется при атаках, так как его просто эксплуатировать. Проблему усугубило то, что в октябре на GitHub <a href="https://github.com/neex/phuip-fpizdam">появился PoC-код для определения уязвимых серверов</a>. Он отправляет специально сформированные запросы, чтобы выяснить, уязвим ли тот или иной сервер. При этом атаки возможны только в отношении NGINX-серверов с включенным PHP-FPM (программным пакетом для обработки скриптов на языке PHP).</p>	<p>Уязвимость найдена в конфигурации nginx, где проброс в PHP-FPM осуществляется c разделением частей URL при помощи <code>fastcgi_split_path_info</code> и определением переменной окружения PATH_INFO, но без предпроверки существования файла директивой <code>try_files $fastcgi_script_name</code> или конструкцией <code>if (!-f $document_root$fastcgi_script_name)</code>.<br><br><img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/c93/164/9e5/c931649e506514b2a9dea46ebb868370.png" alt="image" data-src="https://habrastorage.org/getpro/habr/post_images/c93/164/9e5/c931649e506514b2a9dea46ebb868370.png"><br><br>«С помощью специально сформированного URL атакующий может добиться смещения указателя <code>path_info</code> на первый байт структуры <code>_fcgi_data_seg</code>. Запись нуля в этот байт приведет к перемещению указателя <code>char* pos</code> на ранее идущую область памяти, вызываемый следом <code>FCGI_PUTENV</code> перезаписывает некоторые данные (включая другие переменные ast cgi)», — так описана уязвимость. То есть, хакер может создать фиктивную переменную <code>PHP_VALUE fcgi</code> и добиться выполнения кода.<br><br>Для данной уязвимости уже выпустили патч. Пользователям рекомендовали обновиться до новейших версий PHP 7.3.11 и PHP 7.2.24. Для тех, кто не может обновиться, <a href="https://lab.wallarm.com/php-remote-code-execution-0-day-discovered-in-real-world-ctf-exercise/">представлена инструкция</a> с использованием стандартной утилиты брандмауэра.<br><br>Ранее сообщалось об <a href="https://habr.com/ru/news/t/473110/">обнаружении вредоносной программы Spidey Bot</a>, которая использует легитимный клиент Discord для Windows как средство для шпионажа и кражи информации. Spidey Bot добавляет вредоносный JavaScript, который способен использовать команды Discord API, чтобы собирать данные о пользователе. Затем вся информация передается злоумышленнику через веб-хук Discord.</p>	2023-11-12 17:12:41.7679+00	2023-11-12 17:12:41.7679+00
70	f8e03e4d-5d88-464e-abca-41b3d702caf8	2	Сообщество разработчиков языка PHP учредило некоммерческую организацию PHP Foundation	<p><img src="https://habrastorage.org/r/w1560/webt/t9/9l/qa/t99lqa3f170mtm0t-_saaszotgc.jpeg" data-src="https://habrastorage.org/webt/t9/9l/qa/t99lqa3f170mtm0t-_saaszotgc.jpeg">22 ноября 2021 года <a href="https://www.php.net/archive/2021.php#2021-11-22-1" rel="nofollow noopener noreferrer">сообщество</a> разработчиков языка <a href="https://github.com/php" rel="nofollow noopener noreferrer">PHP</a> учредило некоммерческую организацию <a href="https://opencollective.com/phpfoundation" rel="nofollow noopener noreferrer">PHP Foundation</a>. Цель организации данного независимого образования — создать структуру, отвечающую за организацию финансирования и продвижения проекта PHP, включая поддержку сообщества разработчиков, их трудоустройства и обеспечение им необходимых условий для развития проекта.</p>	<p>На базе PHP Foundation уже начала функционировать система совместного финансирования контрибуторов проекта. В качестве инвесторов в ней могут принять участие как компании, так и физлица. Например, компания JetBrains будет вкладывать туда по $100 тыс. ежегодно. Среди компаний, которые объявили о сотрудничестве с PHP Foundation есть также Automattic, Laravel, Acquia, Zend, Private Packagist, Symfony, Craft CMS, Tideways и PrestaShop.<br><br>В 2022 году PHP Foundation планирует начать выдавать гранты для разработчиков по мере расширения бюджета организации.<br><br>Согласно <a href="https://blog.jetbrains.com/phpstorm/2021/11/the-php-foundation/" rel="nofollow noopener noreferrer">пояснению</a> JetBrains, создание PHP Foundation было обусловлено уходом из компании и проекта PHP одного из его ключевых разработчиков Никиты Попова. Он с 1 декабря начнет работу в новой компании над проектом LLVM. Для того, чтобы другие ключевые разработчики PHP не ушли из проекта в коммерческие структуры, будут использоваться ресурсы PHP Foundation. В JetBrains надеются, что с помощью финансирования PHP Foundation сообщество сможет обеспечить себя в нужном объеме и выплачивать ключевым разработчикам PHP зарплату, соответствующую текущему рыночному уровню. Девиз JetBrains по этой ситуации — «чем больше мы соберем, тем больше разработчиков смогут работать над PHP на полную ставку».</p>	2023-11-12 17:18:37.601835+00	2023-11-12 17:18:37.601835+00
71	ecaa08ee-c181-4d54-8a1b-016f2765743d	2	Крутые доклады, пицца и викторина: приглашаем на Поволжский PHP-митап	<p>14 декабря в Казани пройдет Большая встреча PHP-разработчиков. Участников ждет насыщенная программа: обмен опытом, викторина от подкаста «Пятиминутка PHP», а также угощение пиццей и оригинальные призы.<br><br><img src="https://habrastorage.org/r/w1560/webt/fq/gn/wv/fqgnwvgzqpt1cb2vmdc26neqfko.jpeg" data-src="https://habrastorage.org/webt/fq/gn/wv/fqgnwvgzqpt1cb2vmdc26neqfko.jpeg"></p>	<p>Спикеры-практики расскажут о парсинге, безопасности, работе с микросервисами и многом другом. С докладами выступят Кирилл Несмеянов (Rambler), Максим Шамаев (Skyeng), Александр Макаров (Yii Coreteam), Илья Фроликов (Туту.ру), Алексей Степанков (SimbirSoft) и Леонид Корсаков (независимый разработчик).<br><br>Встреча пройдет в «Точке кипения» в ИТ-Парке, начало в 12.00. Участие бесплатное при условии предварительной <a href="https://leader-id.ru/event/29485/">регистрации</a>.<br><br></p><h2>Доклады:</h2><p><br><strong>1. Про парсинг (Кирилл Несмеянов, Rambler, Москва)</strong><br><br>Регулярные выражениях и чтение сторонних сайтов — это еще не весь парсинг. Мы взглянем на него полноценно. Заглянем под капот языков программирования. Узнаем, именно компиляторы и интерпретаторы читают их исходный код, как реализуются подсветка IDE, статический анализ кода и препроцессоры.<br><br><strong>2. Про трассировку и логирование в микросервисах (Максим Шамаев, Skyeng, Ульяновск)</strong><br><br>Когда вы строите микросервисную архитектуру, никто не думает о плохом :) Но со временем у вас могут появиться проблемы. Я поделюсь нашим опытом решения головной боли “Как всегда понимать, как оно работает в целом” и расскажу, какие результаты и сайд-эффекты дает единообразие логов и правильная трассировка.<br><br><strong>3. Про безопасность: от базовых принципов до особенностей PHP (Александр Макаров, Yii Coreteam, Воронеж)<br></strong><br>Формы, файлы, заголовки HTTP, браузер, консоль, базы данных… Рассмотрим частые угрозы в сети и варианты решения проблем, связанных с ними: XSS, CSRF, DDoS, include, Clickjacking, взлом паролей и не только. Будет жарко!<br><br><strong>4. Миграция с PHP на многопоточную разработку на Go (Илья Фроликов, Туту.ру, Москва)<br></strong><br>Вас ждет реальный практический пример перехода на Golang с обработкой данных в несколько потоков. Сравнение похожего решения на PHP + Rabbit: окружение, простота поддержки, читаемость кода, отказоустойчивость, скорость обработки данных.<br><br><strong>5. Фреймворк на фреймворке, CRUD RESTful API с использованием api-platform и Symfony (Алексей Степанков, SimbirSoft, Ульяновск)<br></strong><br>Все еще пишете кучу логики для каждого API метода? Перебираете кучу библиотек и реализаций в поиске идеального решения? Кое-кто уже поработал за вас. Мы рассмотрим преимущества построения API с использованием фреймворка api-platform на примере фреймворка Symfony, узнаем, что такое JSON-LD и Hydra, а в конце сравним реализации на api-platform и на отдельных библиотеках<br><br><strong>6. Почему код коммерческих проектов пахнет? (Леонид Корсаков, независимый разработчик, Казань)<br></strong><br>Из проекта в проект я наблюдаю одну и ту же картину. В проектах нет код-стайла, код-ревью проводят формально в угоду скорости разработки, а разработчики боятся рефакторить код. Хочу рассказать, почему так жить нельзя, каких ошибок следует избегать для повышения качества кода и как не бояться рефакторить.</p>	2023-11-12 17:20:31.825343+00	2023-11-12 17:20:31.825343+00
72	91efc2e6-78cc-438e-a128-755bc89bfcab	2	Разработку плагина Pest для тестирования кода на PHP теперь ведёт JetBrains	<p>В блоге JetBrains рассказали, что компания <a href="https://blog.jetbrains.com/phpstorm/2023/10/the-pest-plugin-is-now-maintained-by-jetbrains/" rel="noopener noreferrer nofollow">взяла на себя</a> разработку и поддержку плагина <a href="https://plugins.jetbrains.com/plugin/14636-pest" rel="noopener noreferrer nofollow">Pest</a>, предназначенного для работы с одноимённым <a href="https://pestphp.com/" rel="noopener noreferrer nofollow">фреймворком</a> для тестирования кода на PHP. Теперь Pest будет поставляться в комплекте с интегрированной средой разработки PhpStorm, но останется полностью открытым.</p><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/e9a/bd5/bb0/e9abd5bb03a8c0a47e2aa454417db586.jpg" width="1280" height="720" data-src="https://habrastorage.org/getpro/habr/upload_files/e9a/bd5/bb0/e9abd5bb03a8c0a47e2aa454417db586.jpg"></figure>	<p>Плагин Pest для работы с одноимённым фреймворком тестирования кода на PHP в PhpStorm разработал и опубликовал <a href="https://github.com/olivernybroe" rel="noopener noreferrer nofollow">Оливер Найбро</a> (Oliver Nybroe). Команда JetBrains предложила ему объединить его проект со средой разработки PhpStorm, на что он дал своё согласие. Поэтому <a href="https://github.com/pestphp/pest-intellij" rel="noopener noreferrer nofollow">репозиторий</a> Pest перенесли в организацию JetBrains.</p><p>Его развитием теперь занимается команда компании, но оставляет код открытым. Сторонние разработчики могут отправлять свои запросы на включение кода. Следить за качеством кодовой базы будет команда PhpStorm, а проект будет доступен по лицензии MIT. Трекер ошибок и багов в плагине Pest перенесли из GitHub в YouTrack.</p><p>Команда JetBrains уже работает над улучшением Pest. Также сообщили, что с версии 2023.3 Pest будет поставляться как часть PhpStorm.</p>	2023-11-12 17:22:57.988124+00	2023-11-12 17:22:57.988124+00
73	87d7543f-bd11-4e42-82de-3a90360e2ccd	2	Как переход со стека Nginx+FPM на Swoole увеличил производительность PHP API на 91%	<p>Читая <a href="https://habr.com/ru/post/547158/" rel="noopener noreferrer nofollow"><u>PHP-дайджест</u></a>, мы в <a href="https://outstaff.evapps.ru/" rel="noopener noreferrer nofollow">Evapps</a> наткнулись на интересную новость — вовсю идёт голосование по <a href="https://wiki.php.net/rfc/fibers#vote" rel="noopener noreferrer nofollow"><strong><u>[RFC] Fibers</u></strong></a>. В двух словах — это попытки внести немного асинхронности в монолитно-синхронное до сих пор выполнение PHP-кода. А там, глядишь, и до многозадачности недалеко. Но это пока лишь мечты. А в реальности, как оказалось, существует сервис, который УЖЕ создал многопоточность в PHP. Называется он <a href="https://github.com/swoole/swoole-src" rel="noopener noreferrer nofollow"><u>Swoole</u></a>. Кстати, в новом пакете Laravel — Laravel Octane — под капотом будет использоваться именно этот сервис, Swoole. Об этом рассказал создатель Laravel Тейлор во время презентации пакета.</p><p>Рассказывать о Swoole с нуля кажется бессмысленным, так как уже есть люди, которые не просто покрутили сервис на тестовом сервере, но и перевели на него свой проект, получили отличный результат, о котором и отчитались. Хотим с вами поделиться этим отчётом. Представляем перевод статьи основателя компании Appwrite Элдада Фукса <a href="https://eldadfux.medium.com/moving-from-nginx-fpm-to-swoole-has-increased-our-php-api-performance-by-91-40f62e51a064" rel="noopener noreferrer nofollow"><u>Moving From Nginx+FPM to Swoole Has Increased Our PHP API Performance by 91%</u></a>.</p>	<hr><p><strong>В </strong><a href="https://dev.to/appwrite/announcing-the-release-of-appwrite-0-7-the-open-source-firebase-alternative-530d" rel="noopener noreferrer nofollow"><strong><u>прошлом месяце</u></strong></a><strong> мы выпустили Appwrite 0.7 со множеством новых функций. Одно из главных нововведений — мы перешли со стека Nginx + PHP FPM на использование Swoole в качестве HTTP-сервера.</strong></p><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/81e/876/f0d/81e876f0d3adb54a956a394313a727a2.jpeg" width="960" height="629" data-src="https://habrastorage.org/getpro/habr/upload_files/81e/876/f0d/81e876f0d3adb54a956a394313a727a2.jpeg"><figcaption></figcaption></figure><p>В Appwrite мы создаем бесплатную альтернативу Google Firebase — платформу с открытым исходным кодом, которую можно разместить самостоятельно в любой инфраструктуре. Наш стек состоит из набора контейнеров Docker, использующих <a href="https://raw.githubusercontent.com/appwrite/appwrite/4e8d42b95002ea2e012abc74e7576777dc704c45/docs/specs/overview.drawio.svg" rel="noopener noreferrer nofollow"><u>архитектуру микросервисов</u></a>, что позволяет быстро масштабировать и отлаживать отдельные компоненты, составляющие серверный API. Наш backend API является хорошей отправной точкой для создания новых веб-проектов, мобильных проектов или проектов <a href="https://itnext.io/introducing-appwrite-0-6-with-flutter-support-1eb4dce820f3" rel="noopener noreferrer nofollow"><u>Flutter</u></a>. Продукт «‎из коробки» предлагает готовые к использованию модули аутентификации (Auth), хранилище (Storage), базы данных (Database), облачные функции (Cloud Functions) и другие стандартные API-интерфейсы, которые требуются любому приложению, занимающемуся обработкой данных пользователей и разрешений.</p><h2>Как мы используем Swoole</h2><p><a href="https://github.com/swoole/swoole-src" rel="noopener noreferrer nofollow"><u>Swoole</u></a> — это высокопроизводительные, масштабируемые, параллельные TCP, UDP, Unix Socket, HTTP, WebSocket сервисы с PHP и простым в использовании Coroutine fiber API. Используя Swoole, мы имеем всего один многопоточный процесс, запущенный на нашем HTTP-сервере, что позволяет обработчику HTTP-запроса разделять память между несколькими пользователями. С таким подходом мы можем поддерживать постоянные соединения с БД и избегать повторной инициализации приложения с нуля для каждого пользователя, что помогает эффективнее использовать память и процессор.</p><p>Кроме того, Swoole дает возможность использовать корутины (Coroutine). Корутины Swoole подобны корутинам в других языках или фреймворках. Swoole создаёт по одной корутине на каждый запрос и выполняет их, основываясь на IO статусе каждого запроса. Swoole идёт со встроенными <strong>асинхронными клиентами </strong>Redis, MySQL, Postgres<strong>, </strong>позволяя повысить производительность.</p><p>Использование Swoole в качестве веб-сервера отлично подходит при разработке системы для работы в архитектуре микросервисов, подобной нашей. Вместо того, чтобы иметь один контейнер с Supervisord для управления всеми процессами Nginx, FPM и PHP, работающими в фоновом режиме, каждый из наших контейнеров Docker имеет один-единственный процесс в качестве точки входа, который намного проще масштабировать, отлаживать и отслеживать. Вы можете использовать Nginx и PHP в отдельных контейнерах, но они не являются нативными для Docker, и такое их использование ведёт к дополнительным накладным расходам.</p><h2>Benchmarks</h2><p>Чтобы оценить улучшения, мы протестировали различные сценарии в версиях 0.6.2 и 0.7.0. Мы выполняли запросы к нескольким конечным точкам (точкам входа, endpoints) с запросами на чтение и на запись. Все запросы были направлены на конечные точки, которым требуется аутентификация и контроль за злоупотреблениями, то есть на функции, которые выигрывают от этих улучшений.</p><p>Оба теста выполнялись на одном и том же оборудовании и не были направлены на то, чтобы продемонстрировать максимальную производительность Swoole. Цель тестирования заключалась в том, чтобы сравнить работу новой и старой версий. Результаты ниже относятся к 5-минутному нагрузочному и стресс-тестированию с 500 одновременными клиентами, использующими<a href="https://k6.io/" rel="noopener noreferrer nofollow"> <u>K6</u></a>.</p><h3>Версия 0.6.2</h3><figure class="full-width "><img title="Результаты тестов Appwrite 0.6  " src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/59b/efa/3ec/59befa3ecaee648112d8d45a3e1376e9.png" alt="Результаты тестов Appwrite 0.6  " width="948" height="594" data-src="https://habrastorage.org/getpro/habr/upload_files/59b/efa/3ec/59befa3ecaee648112d8d45a3e1376e9.png"><figcaption>Результаты тестов Appwrite 0.6</figcaption></figure><p>Как видно на скриншоте, только 98% всех запросов были успешными. Остальные закончились тайм-аутом из-за перегрузки.</p><h3>Версия 0.7</h3><figure class="full-width "><img title="Результаты тестов Appwrite 0.7  " src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/78c/8e0/73a/78c8e073a9a5076f06c4ec87ffb4fe2a.png" alt="Результаты тестов Appwrite 0.7  " width="1024" height="565" data-src="https://habrastorage.org/getpro/habr/upload_files/78c/8e0/73a/78c8e073a9a5076f06c4ec87ffb4fe2a.png"><figcaption>Результаты тестов Appwrite 0.7</figcaption></figure><p>С версией 0.7 все выглядит иначе. Все запросы, которых было почти в два раза больше, успешно выполнены, а времени на ответ потребовалось примерно вдвое меньше.</p><h2>Результаты</h2><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/7fa/124/6ee/7fa1246ee17bdaf1a3cbeaae0f7f16bb.png" width="702" height="325" data-src="https://habrastorage.org/getpro/habr/upload_files/7fa/124/6ee/7fa1246ee17bdaf1a3cbeaae0f7f16bb.png"><figcaption></figcaption></figure><p>С учетом всех факторов полученные результаты означают, что производительность увеличилась примерно на 91%. Благодаря Swoole наш стек стал намного быстрее и проще в обслуживании. Фактически <a href="http://grigorov.website/blog/performance-comparison-php-vs-node-js" rel="noopener noreferrer nofollow"><u>онлайн-тесты показывают</u></a>, что Swoole + PHP с легкостью опережает популярные альтернативы <a href="http://grigorov.website/blog/performance-comparison-php-vs-node-js" rel="noopener noreferrer nofollow"><u>Node.js</u></a> и Python и не сильно отстает от компилируемых языков, таких как GO.</p><p>Такое повышение производительности — часть действий, которые мы предпринимаем, чтобы дать разработчикам возможность в полной мере использовать свои серверы на основе Appwrite. Мы предоставим больше информации о процессе разработки и тестах Appwrite при запуске новых версий.</p><p>Мы благодарим команду Swoole за поддержку и помощь в процессе миграции, который был на удивление простым и быстрым. Буквально за пару дней мы добрались до первой рабочей версии всего нашего API.</p><h2>Что дальше?</h2><p>Если вы заинтересовались Appwrite (<a href="https://appwrite.io/" rel="noopener noreferrer nofollow"><u>https://appwrite.io</u></a>), ознакомьтесь с руководствами по началу работы для <a href="https://appwrite.io/docs/getting-started-for-web" rel="noopener noreferrer nofollow"><u>Web</u></a>, <a href="https://appwrite.io/docs/getting-started-for-flutter" rel="noopener noreferrer nofollow"><u>Flutter</u></a> или <a href="https://appwrite.io/docs/getting-started-for-server" rel="noopener noreferrer nofollow"><u>Server</u></a>, а также присоединяйтесь к нашему сообществу <a href="https://appwrite.io/discord" rel="noopener noreferrer nofollow"><u>Discord</u></a>, где мы обсуждаем Appwrite с более чем 1300 соавторами платформы.</p><p>Также вы можете посетить наши проекты на <a href="https://github.com/appwrite/appwrite/projects" rel="noopener noreferrer nofollow"><u>Github</u></a>, запросить новые функции в <a href="https://github.com/appwrite/appwrite/issues" rel="noopener noreferrer nofollow"><u>Github issues</u></a> и ознакомиться с будущими спецификациями функций в репозитории <a href="https://github.com/appwrite/rfc" rel="noopener noreferrer nofollow"><u>Appwrite RFCs</u></a>.</p>	2023-11-12 17:25:10.726039+00	2023-11-12 17:25:10.726039+00
74	2c61322f-70e6-4c98-81ad-c04654b49cfe	2	Разработчики из Nginx и F5 представили инструментарий ngx-rust	<figure class=""><img src="https://habrastorage.org/r/w1560/webt/ep/zj/ps/epzjpsvmioy5_du29wk1o2ulkly.jpeg" data-src="https://habrastorage.org/webt/ep/zj/ps/epzjpsvmioy5_du29wk1o2ulkly.jpeg"></figure><p>12 октября 2023 года разработчики из Nginx и F5 <a href="https://www.nginx.com/blog/extending-nginx-with-rust-an-alternative-to-c/" rel="noopener noreferrer nofollow">представили</a> открытый инструментарий <a href="https://github.com/nginxinc/ngx-rust" rel="noopener noreferrer nofollow">ngx-rust</a>. Проект позволяет создавать модули к http-серверу и многопротокольному прокси Nginx на языке программирования Rust. Исходный код ngx-rust выложен на GitHub под лицензией Apache License, проект находится в состоянии бета-версии.</p>	<p>По <a href="https://www.opennet.ru/opennews/art.shtml?num=59923" rel="noopener noreferrer nofollow">данным</a> OpenNET, изначально инструментарий ngx-rust развивался как проект для форсирования разработки Istio-совместимого <a href="https://www.nginx.com/resources/glossary/service-mesh/" rel="noopener noreferrer nofollow">Service mesh</a> для платформы Kubernetes, работающего поверх Nginx. Продукт не вышел за рамки прототипа и несколько лет находился в стагнации, но опубликованные в процессе создания прототипа примеры привязок были использованы сообществом в сторонних проектах (<a href="https://github.com/dcoles/nginx-rs" rel="noopener noreferrer nofollow">1</a>, <a href="https://github.com/arvancloud/nginx-rs" rel="noopener noreferrer nofollow">2</a>) для расширения возможностей Nginx с помощью языка Rust.</p><p>Позже в компании F5 (владелец Nginx) появилась необходимость в создании специализированного модуля к Nginx для защиты своих сервисов, в котором предполагалось использовать язык Rust для снижения риска ошибок при работе с памятью. Для решения задачи был привлечён автор ngx-rust, которому было поручено разработать новый и улучшенный инструментарий для создания модулей к Nginx на языке Rust.</p><p>В текущей версии инструментарий ngx-rust включает два крейт-пакета:</p><ul><li><p>nginx-sys — генератор привязок на основе исходных текстов Nginx. Утилита загружает код Nginx и все связанные с ним зависимости, после чего использует bindgen для формирования обвязок над оригинальными функциями (FFI, foreign function interface);</p></li><li><p>ngx — прослойка для обращения к функциям на C из кода Rust, API и система реэкспорта обвязок, созданных при помощи nginx-sys.</p></li></ul><p>Ранее технический директор Azure и разработчик ПО для Windows (SysInternals) Марк Руссинович <a href="https://habr.com/ru/news/763088/" rel="noopener noreferrer nofollow">сообщил</a>, что запущен открытый проект по включению разработки драйверов для ОС Windows на базе языка программирования Rust. Проект получил название <a href="https://github.com/microsoft/windows-drivers-rs" rel="noopener noreferrer nofollow">windows-drivers-rs</a> и размещён на GitHub с открытыми лицензиями MIT и Apache.</p>	2023-11-12 17:47:05.121299+00	2023-11-12 17:47:05.121299+00
75	0fd39250-f104-4bd0-8aba-f3e97faa4dac	2	Вышел nginx 1.25.0	<p>Вышла новая основная ветка высокопроизводительного HTTP-сервера и многопротокольного прокси-сервера <a href="https://mailman.nginx.org/pipermail/nginx-announce/2023/KEVVKRTAXBWBVXA3DIF5SUKRJWZOEMTM.html" rel="noopener noreferrer nofollow">nginx 1.25.0</a>. В неё <a href="https://nginx.org/en/CHANGES" rel="noopener noreferrer nofollow">добавили</a> модуль ngx_http_v3 с экспериментальной поддержкой протокола HTTP/3. </p><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/e2c/e84/68e/e2ce8468ea8ad33b8f25d8947891b364.jpeg" width="903" height="520" data-src="https://habrastorage.org/getpro/habr/upload_files/e2c/e84/68e/e2ce8468ea8ad33b8f25d8947891b364.jpeg"></figure><p>Модуль отключён по умолчанию. Для активации при сборке он требует указания опции "--with-http_v3_module". Для работы модуля рекомендуется сборка с криптографическими библиотеками, поддерживающими протокол QUIC, такими как BoringSSL, LibreSSL или QuicTLS. При сборке с OpenSSL будет задействован слой для обеспечения совместимости, в котором не поддерживается ранняя отправка данных клиентом (ssl_early_data).</p>	<p>HTTP/3 определяет использование протокола QUIC (Quick UDP Internet Connections) в качестве транспорта для HTTP/2. QUIC — это надстройка над протоколом UDP, поддерживающая мультиплексирование нескольких соединений и обеспечивающая методы шифрования, эквивалентные TLS/SSL. </p><p>В выпуске доступен сервер приложений NGINX Unit 1.30.0, где развивается решение для запуска веб-приложений на различных языках программирования (Python, PHP, Perl, Ruby, Go, JavaScript/Node.js и Java). Под управлением NGINX Unit можно одновременно выполнять несколько приложений на разных языках программирования, параметры запуска которых можно изменять динамически без необходимости правки файлов конфигурации и перезапуска. Код написан на языке Си и распространяется под лицензией Apache 2.0.</p><p>Также в новой версии NGINX Unit добавлена поддержка перезаписи входящих URI в процессе маршрутизации запроса, появилась возможность вычисления значений при определении конфигурации, используя модули и функции JavaScript, а также реализована поддержка вывода в лог диагностических сообщений приложений и отладочных данных о маршрутизации запросов.</p><p>Параллельно поддерживается стабильная ветка 1.24.x, куда будут вносить изменения, связанные с устранением серьёзных ошибок и уязвимостей. В следующем году на базе основной ветки 1.25.x будет сформирована стабильная ветка 1.26.</p><p>В апреле разработчики <a href="https://habr.com/ru/news/728508/" rel="noopener noreferrer nofollow">представили</a> стабильную ветку nginx 1.24.0. В ней по умолчанию включили протокол TLSv1.3.</p>	2023-11-12 17:49:32.622964+00	2023-11-12 17:49:32.622964+00
76	512bb129-3802-4f52-8c20-ac7f8c726e00	2	Путешествие JavaScript-кода через движок V8	<p>С момента своего появления в браузерах, JavaScript зарекомендовал себя как один из самых динамичных и гибких языков программирования. В центре этой динамичности находится движок V8, который превращает скрипты высокого уровня в машинный код, летящий на космических скоростях. Но что на самом деле происходит между строк кода и выполнением программы? Какие механизмы в движке V8 позволяют JavaScript выступать наравне с компилируемыми языками по производительности?</p>	<p>И так давайте рассмотрим более подробно каждый этап исполнения JavaScript-кода движком V8.</p><p>Начнем мы с первого этапа это собственно получение файла с кодом написанным на javaScript</p><figure class="full-width "><img title="Тут все довольно просто , мы просто загружаем файл с js" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/460/134/eb1/460134eb18dc915f5b9bb776c6b00d24.png" alt="Тут все довольно просто , мы просто загружаем файл с js" width="840" height="440" data-src="https://habrastorage.org/getpro/habr/upload_files/460/134/eb1/460134eb18dc915f5b9bb776c6b00d24.png"><figcaption>Тут все довольно просто , мы просто загружаем файл с js</figcaption></figure><p>Далее в дело вступает движок V8 который, парсит JavaScript код и преобразует его в абстрактное синтаксическое дерево <strong>AST(Abstract Syntax Tree)</strong>. AST отражает структуру кода в иерархическом виде с синтаксическими элементами, такими как операторы, объявления переменных, выражения и т.д.</p><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/e05/fbc/404/e05fbc4040feb2ca759ecf36820ab2e4.png" width="1280" height="440" data-src="https://habrastorage.org/getpro/habr/upload_files/e05/fbc/404/e05fbc4040feb2ca759ecf36820ab2e4.png"></figure><p>Далее AST подхватывает компилятор , который берет AST - дерево и преобразуется в байткод, который является более низкоуровневым представлением кода. Этот байткод может быть исполнен интерпретатором, который читает и выполняет байткод инструкция за инструкцией.</p><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/17c/71a/4d1/17c71a4d1db3a532c29d537bbe0dd1b1.png" width="1280" height="518" data-src="https://habrastorage.org/getpro/habr/upload_files/17c/71a/4d1/17c71a4d1db3a532c29d537bbe0dd1b1.png"></figure><p>Несмотря на то , что наш код уже прошел столько этапов , этого не достаточно ведь байт-код это не машинный код. Давайте немного отойдем и вспомним что такое Байт код.</p><blockquote><p><strong>Байт-код</strong> является более высокоуровневым по сравнению с машинным кодом. Он предназначен для выполнения виртуальной машиной (например, Java Virtual Machine или виртуальной машиной JavaScript V8), а не напрямую аппаратным оборудованием.</p></blockquote><p>Далее в работу вступает JIT-компиляция</p><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/167/d92/6ea/167d926eaefeccc2ba7a2775a9723aca.png" width="1280" height="760" data-src="https://habrastorage.org/getpro/habr/upload_files/167/d92/6ea/167d926eaefeccc2ba7a2775a9723aca.png"></figure><p><strong>JIT-компилятор</strong> принимает "горячий" (часто выполняемый) байткод и компилирует его в машинный код для улучшения производительности. Это позволяет программе работать быстрее, поскольку машинный код выполняется непосредственно процессором. Так как я рассказал о том что такое байт-код , думаю не стоит обделять вниманием и машинный код.</p><blockquote><p><strong>Машинный код</strong> — это низкоуровневый код, который исполняется напрямую аппаратным оборудованием процессора. Это последний этап в процессе преобразования кода перед его выполнением.</p></blockquote><p>Я думал на этом закончить , но захотелось с вами поделиться тем , какие оптимизации выполняет JIT с нашим кодом (от исходного вида которого ничего не осталось).</p><ul><li><p><strong>Инлайнинг функций</strong>: Если функция вызывается часто, JIT-компилятор может встроить её код непосредственно в место вызова, чтобы избежать затрат времени на вызов функции.</p></li><li><p><strong>Устранение избыточных операций</strong>: Компилятор может определить и удалить операции, которые не влияют на результат (например, вычисления, которые никогда не используются).</p></li><li><p><strong>Типовая специализация</strong>: Компилятор делает предположения о типах данных и оптимизирует код под эти типы. Если предположения нарушаются (например, функция, которая всегда получала числа, вдруг получает строку), код может быть "деоптимизирован" и заново скомпилирован с менее специфичными оптимизациями.</p></li><li><p><strong>Оптимизация циклов</strong>: Переупорядочивание и улучшение циклов для уменьшения количества инструкций и количества обращений к памяти.</p></li><li><p><strong>Удаление мертвого кода</strong>: Код, который никогда не достижим во время исполнения, удаляется.</p></li></ul><p>Ну и в заключении машинный код который, сгенерировал JIT-компилятор, выполняется процессором. Это самая быстрая фаза выполнения кода, поскольку процессор обрабатывает машинный код напрямую.</p><h2>Заключение</h2><p><em>Понимание того, как V8 превращает строки JavaScript в машинный код, может дать разработчикам преимущество при написании оптимизированного кода. В следующих разделах мы рассмотрим каждый этап процесса более подробно, чтобы вы могли понять, как наиболее эффективно взаимодействовать с этим мощным инструментом.</em></p>	2023-11-13 14:10:54.374568+00	2023-11-13 14:10:54.374568+00
77	d444d609-fcdc-4159-99fb-034b42f9ea5d	2	Microsoft поддерживает добавление в JavaScript необязательного и стираемого синтаксиса типов	<p>Microsoft <a href="https://devblogs.microsoft.com/typescript/a-proposal-for-type-syntax-in-javascript/" rel="noopener noreferrer nofollow">поддержала</a> предложение добавить в JavaScript необязательный и стираемый синтаксис типов, чтобы сделать язык TypeScript быстрее и проще в использовании.</p><figure class="full-width "><img src="https://habrastorage.org/getpro/habr/upload_files/dd1/5db/b69/dd15dbb69a3e402b22b992bc8a78d030.JPG" width="1284" height="674"><figcaption></figcaption></figure><p>В новом сообщении в блоге софтверный гигант предоставил дополнительную информацию об этом предложении и о том, каковы его цели. По сути, предложение требует добавления аннотаций типов в код JavaScript, которые могут быть проверены внешними средствами проверки типов и обработаны как комментарии движком JavaScript во время выполнения.</p>	<p>В рамках предложения также необходимо создать набор синтаксиса для типов, которые движки будут игнорировать, но смогут использовать TypeScript, Flow и другие инструменты. Если предложение будет одобрено, разработчики смогут запускать программы на TypeScript, Flow и других языках. </p><p>Новое предложение выдвинули Гил Тайар, Даниэль Розенвассер из Microsoft, Ромуло Синтра из Igalia и Роб Палмер из Bloomberg. Его опубликовали на GitHub. В этом месяце команда представит свое предложение комитету по стандартам ECMAScript.</p><figure class="full-width "><img src="https://habrastorage.org/getpro/habr/upload_files/57f/a31/fb8/57fa31fb8f9b6ed3fa87198cbe2e7c5a.JPG" width="1346" height="642"><figcaption></figcaption></figure><p>Авторы идеи заявили, что за последнее десятилетие статическая проверка типов оказалась довольно успешной. В дополнение к TypeScript от Microsoft, Google создал свой Closure Compiler, а Facebook представил Flow. Статическая типизация <a href="https://2021.stateofjs.com/en-US/opinions/" rel="noopener noreferrer nofollow">была признана</a> функцией номер один, отсутствующей в языке программирования. 69% респондентов в опросе State of JavaScript 2021 года заявили, что они используют TypeScript для компиляции JavaScript.</p><p>Стоит отметить, что Microsoft не призывает добавлять проверку типов TypeScript в каждый браузер и среду выполнения JavaScript. Вместо этого компания предложила синтаксис JavaScript, совместимый с TypeScript, который может использоваться любым средством проверки типов, но при этом игнорироваться механизмами JavaScript. Чтобы это произошло, в JavaScript минимально потребуется добавить синтаксис для таких вещей, как аннотации типов для переменных и функций, модификаторы опциональности для параметров и членов класса, объявления типов (интерфейсы и псевдонимы типов) и операторы утверждения типа — все это не повлияет на выполнение кода. Такие функции, как модификаторы видимости (например, общедоступные, частные и защищенные), могут быть предложены как отдельные функции ECMAScript.</p>	2023-11-13 14:13:38.508202+00	2023-11-13 14:13:38.508202+00
79	66ed0b23-892b-47c5-abc2-b696bb7f2408	2	Состоялся релиз Bun 1.0 — среды выполнения JavaScript и TypeScript	<figure class=""><img src="https://habrastorage.org/r/w1560/webt/td/r2/mz/tdr2mzlkombqmudkv1j4xydnkei.png" data-src="https://habrastorage.org/webt/td/r2/mz/tdr2mzlkombqmudkv1j4xydnkei.png"></figure><p>Состоялся <a href="https://bun.sh/blog/bun-v1.0" rel="noopener noreferrer nofollow">релиз Bun 1.0</a> - среды выполнения JavaScript и TypeScript с возможностью отладки кода и поддержкой популярных веб-фрейворков.</p>	<p><a href="https://bun.sh/" rel="noopener noreferrer nofollow">Bun</a> — это современная среда выполнения JS типа Node.js или Deno со встроенной поддержкой JSX и TypeScript. Она <a href="https://habr.com/ru/companies/timeweb/articles/710202/" rel="noopener noreferrer nofollow">разработана</a> с акцентом на быстром запуске, высокой производительности и самодостаточности. Внутри Bun есть транспилятор (транспилирующий компилятор) JavaScript, встроенный в среду выполнения. Это означает, что при работе с Bun можно запускать файлы JavaScript, TypeScript и даже JSX/TSX без каких-либо зависимостей.</p><p>Bun использует движок JavaScriptCore, разрабатываемый WebKit, который запускается и выполняет операции немного быстрее, а также использует память немного эффективнее, чем классические движки типа V8. Bun написан на Zig — языке программирования низкого уровня с ручным управлением памятью, чем объясняются высокие показатели его скорости.</p><p>В Bun работают полнофункциональные приложения, созданные с помощью Next.js, Remix, Nuxt, Astro, SvelteKit, Nest, SolidStart и Vite.</p><p>Разработчики проекта пояснили, что Bun запускается в 4 раза быстрее, чем Node.js. Эта разница только увеличивается при запуске файла TypeScript, который требует транспиляции, прежде чем Node.js сможет его запустить. Bun запускает тестовый файл hello world на TypeScript в 5 раз быстрее, чем esbuild с Node.js.</p><figure class=""><img src="https://habrastorage.org/r/w1560/webt/d0/jj/gc/d0jjgc4erdj8jw1xuoyide4jj9a.jpeg" data-src="https://habrastorage.org/webt/d0/jj/gc/d0jjgc4erdj8jw1xuoyide4jj9a.jpeg"></figure><p>Bun можно использовать не только в качестве среды выполнения, а ещё и как встроенный менеджер пакетов, который может ускорить рабочий процесс разработки. Разработчики рассказали, что Bun на несколько порядков быстрее, чем npm, Yarn и pnpm. Проект использует глобальный кеш модулей, чтобы избежать избыточных загрузок из реестра npm, а также задействует самые быстрые системные вызовы, доступные в каждой операционной системе.</p><figure class=""><img src="https://habrastorage.org/r/w1560/webt/ay/pm/xt/aypmxtsqdhkpu2p-4khveszeepu.png" data-src="https://habrastorage.org/webt/ay/pm/xt/aypmxtsqdhkpu2p-4khveszeepu.png"></figure><p>В рамках проекта Bun предоставлены сборки для macOS и Linux. Раньше, чтобы запустить Bun в Windows, нужно было установить подсистему Windows для Linux. Но теперь вышла экспериментальная встроенная сборку Bun для Windows. На данный момент в ней поддерживается только среда выполнения JavaScript, а менеджер пакетов и средство запуска тестов и сборщик отключены до тех пор, пока они не станут более стабильными. Производительность этой сборки также пока не оптимизирована. Разработчики проекта обещают, что в ближайшее время улучшать поддержку Windows для работы с Bun.</p>	2023-11-13 14:17:14.987333+00	2023-11-13 14:17:14.987333+00
80	5a92f262-2a03-493f-b9dd-5d5c2d8d98e3	2	Создатель Node.js попросил Oracle сделать общедоступным товарный знак JavaScript	<p><img src="https://habrastorage.org/r/w1560/webt/ue/ow/aa/ueowaarrj6vklb9kvxh2-kh-xeq.png" width="607" height="435" data-src="https://habrastorage.org/webt/ue/ow/aa/ueowaarrj6vklb9kvxh2-kh-xeq.png"><br><br>Создатель Node.js и автор Deno Райан Даль в открытом письме <a href="https://tinyclouds.org/trademark" rel="nofollow noopener noreferrer">попросил</a> компанию Oracle сделать общедоступным товарный знак <a href="https://tsdr.uspto.gov/#caseNumber=75026640&amp;caseType=SERIAL_NO&amp;searchType=statusSearch" rel="nofollow noopener noreferrer">JavaScript</a>.</p>	<p>Даль <a href="https://web.archive.org/web/20020606002913/http://wp.netscape.com/newsref/pr/newsrelease67.html" rel="nofollow noopener noreferrer">напомнил</a>, что в 1995 году Netscape заключила партнёрское соглашение с Sun Microsystems для создания интерактивных веб-сайтов. Разработчик Брендан Айк <a href="https://habr.com/ru/post/313040/">за 10 дней без сна</a> создал первую версию JavaScript — динамического языка программирования, который только примерно синтаксически восходит к языку Java компании Sun. В результате этого партнёрства Sun получила торговую марку JavaScript. В 2009 году Oracle приобрела Sun Microsystems, и ей досталась в итоге торговая марка на <a href="https://tsdr.uspto.gov/#caseNumber=75026640&amp;caseType=SERIAL_NO&amp;searchType=statusSearch" rel="nofollow noopener noreferrer">JavaScript</a>.<br><br>Айк этому поводу ранее <a href="https://devclass.com/2022/08/04/retire_javascript_says-json-creator-douglas-crockford/" rel="nofollow noopener noreferrer">пояснил</a>, что JavaScript не столько связан с Java, сколько с общим предком C в синтаксисе. Он сделал именно язык программирования для HTML, для использования веб-дизайнерами и программистами, встроенный непосредственно в веб-страницу, в отличие от профессионального языка Java, где нужно запускать реальный код с объявлениями типов и использовать мощный компилятор. Айк назвал первые 10 дней создания JavaScript «срочной работой, выполняя которую, он знал, что там будут ошибки и пробелы». Поэтому он создал этот язык очень гибким, что в итоге позволило веб-разработчикам сделать его таким, каким они хотят его видеть.<br><br>Даль пояснил, что сам по себе товарный знак на JavaScript не имеет коммерческой ценности, так как кроме <a href="https://www.oracle.com/webfolder/technetwork/jet/index.html" rel="nofollow noopener noreferrer">Oracle JavaScript Extension Toolkit</a> у Oracle нет продуктов, использующих этот товарный знак, и, предположительно, не запланировано их использование. По его словам, Oracle не участвует в разработке каких-либо версий движков JavaScript, например, V8, JavaScriptCore или Spidermonkey. Даль предполагает, что, весьма вероятно, нарушение прав на товарный знак JavaScript не будет иметь исковой силы в суде из-за несоблюдения правил его <a href="https://www.uspto.gov/trademarks/maintain/keeping-your-registration-alive" rel="nofollow noopener noreferrer">неиспользования</a> со стороны Oracle, но компании нужно показать это самой и сделать открытым для сообщества.<br><br>«Тем не менее, торговая марка — это тёмная туча, нависшая над самым популярным в мире языком программирования. Осторожные и законопослушные разработчики из кожи вон лезут, чтобы избежать его использования, что приводит к запутанным терминам, таким как ECMAScript», — уточнил Даль.<br><br>В руководящих принципах Oracle <a href="https://www.oracle.com/legal/trademarks.html" rel="nofollow noopener noreferrer">прописано</a> про товарные знаки, что «надлежащее использование товарных знаков Oracle укрепляет их роль в качестве брендов для продуктов и услуг компании и помогает предотвратить превращение их в общие названия, которые может использовать кто угодно». В компании даже прописали примеры бывших товарных знаков, которые стали общими терминами: «аспирин», «целлофан» и «эскалатор». Oracle просит всех партнёров соблюдать правила для защиты инвестиций Oracle в свои товарные знаки.<br><br>«Наилучшая ценность, которую Oracle может извлечь из товарного знака, — это репутация, которую она получит, передавая его в общественное достояние. Понятно, почему этого до сих пор не произошло — потребовался бы очень дальновидный и высокопоставленный сотрудник Oracle, чтобы предложить что-то столь неосязаемое. Тем не менее, очевидно, что это правильный шаг — обменять бесполезную торговую марку на бренд-маркетинг и репутацию», — считает Даль.<br><br>«Oracle, освободите товарный знак JavaScript», — подытожил Даль.</p>	2023-11-13 14:22:23.463857+00	2023-11-14 09:42:39.618312+00
\.


--
-- Data for Name: tag; Type: TABLE DATA; Schema: public; Owner: blog
--

COPY public.tag (id, label) FROM stdin;
24	postgresql
27	cloud
28	solutionspostgres
29	propg
31	postgres
60	mail.ru
61	postgres pro
62	oracle
63	субд
64	windows
65	postgres professional
66	postgres pro standard
67	postgres pro enterprise
72	vk cloud
73	база данных
74	облака
75	облачный сервис
76	pgsql
77	базы данных
78	обфускация
79	учебник
80	книга
81	postgresql 15 изнутри
82	postgresql 15
83	история создания
84	абстрактные типы данных
85	индексирование
86	восстановление
87	никто не читает теги
88	dbms
89	sql server
90	php
91	cutcode
92	laravel
93	дайджест
94	php-дайджест
95	php 8.0
96	релиз
97	phpunit
102	microsoft
103	no support
104	php 7
105	баги
106	серверы
108	nginx
109	нко
110	php foundation
111	jetbrains
142	simbirsoft
143	митап
144	казань
145	pest
146	phpstorm
147	плагин
148	разработка
149	ide
150	тестирование
151	софт
152	перевод
153	swoole
154	rust
155	ngx-rust
156	nginx unit
157	nginx module
158	ветка
159	http 3
160	модуль
161	http сервер
162	прокси сервер
163	стабильная версия
164	v8
165	v8js
166	движок
167	исполнение кода
168	javascript
169	typescript
170	синтаксис
171	синтаксис typescript
172	синтаксис javascript
173	языки программирования
174	отладка
175	рефакторинг
176	bun
177	даль
178	доступность
179	товарный знак
\.


--
-- Data for Name: post_tags; Type: TABLE DATA; Schema: public; Owner: blog
--

COPY public.post_tags (tag_id, post_id) FROM stdin;
24	22
24	23
27	23
28	23
29	23
31	23
60	23
24	56
31	56
61	56
62	56
63	57
64	57
65	57
66	57
67	57
61	59
63	59
67	59
72	59
73	59
74	59
75	59
63	60
67	60
76	60
77	60
78	60
24	61
61	61
79	61
80	61
81	61
82	61
24	62
31	62
83	62
84	62
85	62
86	62
87	62
24	63
31	63
63	63
77	63
88	63
24	64
31	64
89	64
90	65
91	65
92	65
93	65
94	65
90	66
95	66
96	66
95	68
102	68
103	68
90	69
104	69
105	69
106	69
108	69
90	70
109	70
110	70
111	70
90	71
142	71
143	71
144	71
90	72
111	72
145	72
146	72
147	72
148	72
149	72
150	72
151	72
90	73
92	73
97	73
108	73
152	73
153	73
108	74
154	74
155	74
96	75
108	75
156	75
157	75
158	75
159	75
160	75
161	75
162	75
163	75
164	76
165	76
166	76
167	76
168	76
102	77
168	77
169	77
170	77
171	77
172	77
173	77
150	78
154	78
168	78
174	78
175	78
168	79
169	79
176	79
62	80
168	80
177	80
178	80
179	80
\.


--
-- Name: account_id_seq; Type: SEQUENCE SET; Schema: public; Owner: blog
--

SELECT pg_catalog.setval('public.account_id_seq', 5, true);


--
-- Name: post_id_seq; Type: SEQUENCE SET; Schema: public; Owner: blog
--

SELECT pg_catalog.setval('public.post_id_seq', 80, true);


--
-- Name: tag_id_seq; Type: SEQUENCE SET; Schema: public; Owner: blog
--

SELECT pg_catalog.setval('public.tag_id_seq', 180, true);


--
-- PostgreSQL database dump complete
--

